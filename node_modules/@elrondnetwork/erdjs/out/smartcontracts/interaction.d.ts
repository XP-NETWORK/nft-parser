import { Transaction } from "../transaction";
import { Query } from "./query";
import { ContractFunction } from "./function";
import { EndpointDefinition, TypedValue } from "./typesystem";
import { Account } from "../account";
import { CallArguments } from "./interface";
import { IAddress, IChainID, IGasLimit, IGasPrice, INonce, ITokenPayment, ITransactionValue } from "../interface";
/**
 * Internal interface: the smart contract, as seen from the perspective of an {@link Interaction}.
 */
interface ISmartContractWithinInteraction {
    call({ func, args, value, gasLimit, receiver }: CallArguments): Transaction;
    getAddress(): IAddress;
    getEndpoint(name: ContractFunction): EndpointDefinition;
}
/**
 * Interactions can be seen as mutable transaction & query builders.
 *
 * Aside from building transactions and queries, the interactors are also responsible for interpreting
 * the execution outcome for the objects they've built.
 */
export declare class Interaction {
    private readonly contract;
    private readonly function;
    private readonly args;
    private nonce;
    private value;
    private gasLimit;
    private gasPrice;
    private chainID;
    private querent;
    private explicitReceiver?;
    private isWithSingleESDTTransfer;
    private isWithSingleESDTNFTTransfer;
    private isWithMultiESDTNFTTransfer;
    private tokenTransfers;
    private tokenTransfersSender;
    constructor(contract: ISmartContractWithinInteraction, func: ContractFunction, args: TypedValue[]);
    getContractAddress(): IAddress;
    getFunction(): ContractFunction;
    getEndpoint(): EndpointDefinition;
    getArguments(): TypedValue[];
    getValue(): ITransactionValue;
    getTokenTransfers(): ITokenPayment[];
    getGasLimit(): IGasLimit;
    getExplicitReceiver(): IAddress | undefined;
    buildTransaction(): Transaction;
    buildQuery(): Query;
    withValue(value: ITransactionValue): Interaction;
    withSingleESDTTransfer(transfer: ITokenPayment): Interaction;
    withSingleESDTNFTTransfer(transfer: ITokenPayment, sender: IAddress): this;
    withMultiESDTNFTTransfer(transfers: ITokenPayment[], sender: IAddress): this;
    withGasLimit(gasLimit: IGasLimit): Interaction;
    withGasPrice(gasPrice: IGasPrice): Interaction;
    withNonce(nonce: INonce): Interaction;
    useThenIncrementNonceOf(account: Account): Interaction;
    withChainID(chainID: IChainID): Interaction;
    /**
     * Sets the "caller" field on contract queries.
     */
    withQuerent(querent: IAddress): Interaction;
    withExplicitReceiver(receiver: IAddress): Interaction;
    /**
     * To perform custom checking, extend {@link Interaction} and override this method.
     */
    check(): Interaction;
}
export {};
