"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NativeSerializer = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const typesystem_1 = require("./typesystem");
const argumentErrorContext_1 = require("./argumentErrorContext");
const typesystem_2 = require("./typesystem");
const address_1 = require("../address");
const errors_1 = require("../errors");
const utils_codec_1 = require("../utils.codec");
var NativeSerializer;
(function (NativeSerializer) {
    /**
     * Interprets a set of native javascript values into a set of typed values, given parameter definitions.
     */
    function nativeToTypedValues(args, endpoint) {
        args = args || [];
        assertNotTypedValues(args);
        args = handleVariadicArgsAndRePack(args, endpoint);
        let parameters = endpoint.input;
        let values = [];
        for (let i = 0; i < parameters.length; i++) {
            let parameter = parameters[i];
            let errorContext = new argumentErrorContext_1.ArgumentErrorContext(endpoint.name, i, parameter);
            let value = convertToTypedValue(args[i], parameter.type, errorContext);
            values.push(value);
        }
        return values;
    }
    NativeSerializer.nativeToTypedValues = nativeToTypedValues;
    function assertNotTypedValues(args) {
        for (let i = 0; i < args.length; i++) {
            let arg = args[i];
            if (arg && arg.belongsToTypesystem) {
                throw new errors_1.ErrTypeInferenceSystemRequiresRegularJavascriptObjects(i);
            }
        }
    }
    function handleVariadicArgsAndRePack(args, endpoint) {
        let parameters = endpoint.input;
        let { min, max, variadic } = getArgumentsCardinality(parameters);
        if (!(min <= args.length && args.length <= max)) {
            throw new errors_1.ErrInvalidArgument(`Wrong number of arguments for endpoint ${endpoint.name}: expected between ${min} and ${max} arguments, have ${args.length}`);
        }
        if (variadic) {
            let lastArgIndex = parameters.length - 1;
            let lastArg = args.slice(lastArgIndex);
            args[lastArgIndex] = lastArg;
        }
        return args;
    }
    // A function may have one of the following formats:
    // f(arg1, arg2, optional<arg3>, optional<arg4>) returns { min: 2, max: 4, variadic: false }
    // f(arg1, variadic<bytes>) returns { min: 1, max: Infinity, variadic: true }
    // f(arg1, arg2, optional<arg3>, arg4, optional<arg5>, variadic<bytes>) returns { min: 2, max: Infinity, variadic: true }
    function getArgumentsCardinality(parameters) {
        let reversed = [...parameters].reverse(); // keep the original unchanged
        let min = parameters.length;
        let max = parameters.length;
        let variadic = false;
        if (reversed.length > 0 && reversed[0].type.getCardinality().isComposite()) {
            max = Infinity;
            variadic = true;
        }
        for (let parameter of reversed) {
            if (parameter.type.getCardinality().isSingular()) {
                break;
            }
            min -= 1;
        }
        return { min, max, variadic };
    }
    function convertToTypedValue(native, type, errorContext) {
        if (type instanceof typesystem_1.OptionType) {
            return toOptionValue(native, type, errorContext);
        }
        if (type instanceof typesystem_1.OptionalType) {
            return toOptionalValue(native, type, errorContext);
        }
        if (type instanceof typesystem_1.VariadicType) {
            return toVariadicValue(native, type, errorContext);
        }
        if (type instanceof typesystem_1.CompositeType) {
            return toCompositeValue(native, type, errorContext);
        }
        if (type instanceof typesystem_1.TupleType) {
            return toTupleValue(native, type, errorContext);
        }
        if (type instanceof typesystem_2.StructType) {
            return toStructValue(native, type, errorContext);
        }
        if (type instanceof typesystem_1.ListType) {
            return toListValue(native, type, errorContext);
        }
        if (type instanceof typesystem_1.PrimitiveType) {
            return toPrimitive(native, type, errorContext);
        }
        errorContext.throwError(`convertToTypedValue: unhandled type ${type}`);
    }
    function toOptionValue(native, type, errorContext) {
        if (native == null) {
            return typesystem_1.OptionValue.newMissing();
        }
        let converted = convertToTypedValue(native, type.getFirstTypeParameter(), errorContext);
        return typesystem_1.OptionValue.newProvided(converted);
    }
    function toOptionalValue(native, type, errorContext) {
        if (native == null) {
            return new typesystem_1.OptionalValue(type);
        }
        let converted = convertToTypedValue(native, type.getFirstTypeParameter(), errorContext);
        return new typesystem_1.OptionalValue(type, converted);
    }
    function toVariadicValue(native, type, errorContext) {
        if (native == null) {
            native = [];
        }
        if (native.map === undefined) {
            errorContext.convertError(native, "Variadic");
        }
        let converted = native.map(function (item) {
            return convertToTypedValue(item, type.getFirstTypeParameter(), errorContext);
        });
        return new typesystem_1.VariadicValue(type, converted);
    }
    function toListValue(native, type, errorContext) {
        if (native.map === undefined) {
            errorContext.convertError(native, "List");
        }
        let converted = native.map(function (item) {
            return convertToTypedValue(item, type.getFirstTypeParameter(), errorContext);
        });
        return new typesystem_1.List(type, converted);
    }
    function toCompositeValue(native, type, errorContext) {
        let typedValues = [];
        let typeParameters = type.getTypeParameters();
        errorContext.guardSameLength(native, typeParameters);
        for (let i = 0; i < typeParameters.length; i++) {
            typedValues.push(convertToTypedValue(native[i], typeParameters[i], errorContext));
        }
        return new typesystem_1.CompositeValue(type, typedValues);
    }
    function toTupleValue(native, type, errorContext) {
        let typedValues = [];
        const fields = type.getFieldsDefinitions();
        errorContext.guardSameLength(native, fields);
        for (let i = 0; i < fields.length; i++) {
            typedValues.push(convertToTypedValue(native[i], fields[i].type, errorContext));
        }
        return typesystem_2.Tuple.fromItems(typedValues);
    }
    function toStructValue(native, type, errorContext) {
        let structFieldValues = [];
        const fields = type.getFieldsDefinitions();
        for (let i = 0; i < fields.length; i++) {
            const fieldName = fields[i].name;
            errorContext.guardHasField(native, fieldName);
            const fieldNativeValue = native[fieldName];
            const fieldTypedValue = convertToTypedValue(fieldNativeValue, fields[i].type, errorContext);
            structFieldValues.push(new typesystem_2.Field(fieldTypedValue, fieldName));
        }
        return new typesystem_2.Struct(type, structFieldValues);
    }
    function toPrimitive(native, type, errorContext) {
        if (type instanceof typesystem_1.NumericalType) {
            let number = new bignumber_js_1.default(native);
            return convertNumericalType(number, type, errorContext);
        }
        if (type instanceof typesystem_1.BytesType) {
            return convertNativeToBytesValue(native, errorContext);
        }
        if (type instanceof typesystem_1.AddressType) {
            return new typesystem_1.AddressValue(convertNativeToAddress(native, errorContext));
        }
        if (type instanceof typesystem_1.BooleanType) {
            return new typesystem_1.BooleanValue(native);
        }
        if (type instanceof typesystem_1.TokenIdentifierType) {
            return new typesystem_1.TokenIdentifierValue(convertNativeToString(native, errorContext));
        }
        errorContext.throwError(`(function: toPrimitive) unsupported type ${type}`);
    }
    function convertNativeToBytesValue(native, errorContext) {
        const innerValue = native.valueOf();
        if (native === undefined) {
            errorContext.convertError(native, "BytesValue");
        }
        if (native instanceof Buffer) {
            return new typesystem_1.BytesValue(native);
        }
        if (typeof native === "string") {
            return typesystem_1.BytesValue.fromUTF8(native);
        }
        if (innerValue instanceof Buffer) {
            return new typesystem_1.BytesValue(innerValue);
        }
        if (typeof innerValue === "number") {
            return typesystem_1.BytesValue.fromHex(utils_codec_1.numberToPaddedHex(innerValue));
        }
        errorContext.convertError(native, "BytesValue");
    }
    function convertNativeToString(native, errorContext) {
        if (native === undefined) {
            errorContext.convertError(native, "Buffer");
        }
        if (native instanceof Buffer) {
            return native.toString();
        }
        if (typeof native === "string") {
            return native;
        }
        errorContext.convertError(native, "Buffer");
    }
    function convertNativeToAddress(native, errorContext) {
        if (native.bech32) {
            return native;
        }
        if (native.getAddress) {
            return native.getAddress();
        }
        switch (native.constructor) {
            case Buffer:
            case String:
                return new address_1.Address(native);
            default:
                errorContext.convertError(native, "Address");
        }
    }
    NativeSerializer.convertNativeToAddress = convertNativeToAddress;
    function convertNumericalType(number, type, errorContext) {
        switch (type.constructor) {
            case typesystem_1.U8Type:
                return new typesystem_1.U8Value(number);
            case typesystem_1.I8Type:
                return new typesystem_1.I8Value(number);
            case typesystem_1.U16Type:
                return new typesystem_1.U16Value(number);
            case typesystem_1.I16Type:
                return new typesystem_1.I16Value(number);
            case typesystem_1.U32Type:
                return new typesystem_1.U32Value(number);
            case typesystem_1.I32Type:
                return new typesystem_1.I32Value(number);
            case typesystem_1.U64Type:
                return new typesystem_1.U64Value(number);
            case typesystem_1.I64Type:
                return new typesystem_1.I64Value(number);
            case typesystem_1.BigUIntType:
                return new typesystem_1.BigUIntValue(number);
            case typesystem_1.BigIntType:
                return new typesystem_1.BigIntValue(number);
            default:
                errorContext.unhandledType("convertNumericalType", type);
        }
    }
})(NativeSerializer = exports.NativeSerializer || (exports.NativeSerializer = {}));
//# sourceMappingURL=nativeSerializer.js.map