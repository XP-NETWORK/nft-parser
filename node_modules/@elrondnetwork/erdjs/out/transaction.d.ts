/// <reference types="node" />
import { BigNumber } from "bignumber.js";
import { IAddress, IChainID, IGasLimit, IGasPrice, INonce, IPlainTransactionObject, ISignature, ITransactionPayload, ITransactionValue } from "./interface";
import { TransactionOptions, TransactionVersion } from "./networkParams";
import { Hash } from "./hash";
import { INetworkConfig } from "./interfaceOfNetwork";
/**
 * An abstraction for creating, signing and broadcasting Elrond transactions.
 */
export declare class Transaction {
    /**
     * The nonce of the transaction (the account sequence number of the sender).
     */
    private nonce;
    /**
     * The value to transfer.
     */
    private value;
    /**
     * The address of the sender.
     */
    private sender;
    /**
     * The address of the receiver.
     */
    private readonly receiver;
    /**
     * The gas price to be used.
     */
    private gasPrice;
    /**
     * The maximum amount of gas to be consumed when processing the transaction.
     */
    private gasLimit;
    /**
     * The payload of the transaction.
     */
    private readonly data;
    /**
     * The chain ID of the Network (e.g. "1" for Mainnet).
     */
    private chainID;
    /**
     * The version, required by the Network in order to correctly interpret the contents of the transaction.
     */
    version: TransactionVersion;
    /**
     * The options field, useful for describing different settings available for transactions
     */
    options: TransactionOptions;
    /**
     * The signature.
     */
    private signature;
    /**
     * The transaction hash, also used as a transaction identifier.
     */
    private hash;
    /**
     * Creates a new Transaction object.
     */
    constructor({ nonce, value, receiver, sender, gasPrice, gasLimit, data, chainID, version, options, }: {
        nonce?: INonce;
        value?: ITransactionValue;
        receiver: IAddress;
        sender?: IAddress;
        gasPrice?: IGasPrice;
        gasLimit: IGasLimit;
        data?: ITransactionPayload;
        chainID: IChainID;
        version?: TransactionVersion;
        options?: TransactionOptions;
    });
    getNonce(): INonce;
    /**
     * Sets the account sequence number of the sender. Must be done prior signing.
     */
    setNonce(nonce: INonce): void;
    getValue(): ITransactionValue;
    setValue(value: ITransactionValue): void;
    getSender(): IAddress;
    getReceiver(): IAddress;
    getGasPrice(): IGasPrice;
    setGasPrice(gasPrice: IGasPrice): void;
    getGasLimit(): IGasLimit;
    setGasLimit(gasLimit: IGasLimit): void;
    getData(): ITransactionPayload;
    getChainID(): IChainID;
    setChainID(chainID: IChainID): void;
    getVersion(): TransactionVersion;
    getOptions(): TransactionOptions;
    getSignature(): ISignature;
    getHash(): TransactionHash;
    /**
     * Serializes a transaction to a sequence of bytes, ready to be signed.
     * This function is called internally by signers.
     *
     * @param signedBy The address of the future signer
     */
    serializeForSigning(signedBy: IAddress): Buffer;
    /**
     * Converts the transaction object into a ready-to-serialize, plain JavaScript object.
     * This function is called internally within the signing procedure.
     *
     * @param sender The address of the sender (will be provided when called within the signing procedure)
     */
    toPlainObject(sender?: IAddress): IPlainTransactionObject;
    /**
     * Converts a plain object transaction into a Transaction Object.
     *
     * @param plainObjectTransaction Raw data of a transaction, usually obtained by calling toPlainObject()
     */
    static fromPlainObject(plainObjectTransaction: IPlainTransactionObject): Transaction;
    /**
     * Applies the signature on the transaction.
     *
     * @param signature The signature, as computed by a signer.
     * @param signedBy The address of the signer.
     */
    applySignature(signature: ISignature, signedBy: IAddress): void;
    /**
     * Converts a transaction to a ready-to-broadcast object.
     * Called internally by the network provider.
     */
    toSendable(): any;
    /**
     * Computes the current transaction fee based on the {@link NetworkConfig} and transaction properties
     * @param networkConfig {@link NetworkConfig}
     */
    computeFee(networkConfig: INetworkConfig): BigNumber;
}
/**
 * An abstraction for handling and computing transaction hashes.
 */
export declare class TransactionHash extends Hash {
    constructor(hash: string);
    /**
     * Computes the hash of a transaction.
     */
    static compute(transaction: Transaction): TransactionHash;
}
