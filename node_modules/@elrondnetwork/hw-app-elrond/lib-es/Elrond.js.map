{"version":3,"sources":["../src/Elrond.js"],"names":["SIGN_RAW_TX_INS","SIGN_HASH_TX_INS","SIGN_MESSAGE_INS","GET_ADDRESS_AUTH_TOKEN_INS","ACTIVE_SIGNERS","Elrond","constructor","transport","scrambleKey","decorateAppAPIMethods","getAddress","account","index","display","cla","ins","p1","p2","data","Buffer","alloc","writeInt32BE","writeUInt32BE","response","send","addressLength","address","slice","toString","setAddress","signTransaction","rawTx","usingHash","sign","signMessage","message","getAddressAndSignAuthToken","token","length","buffersArray","result","concat","splitRes","split","signature","getAppConfiguration","contractData","accountIndex","addressIndex","version","type","includes","Error","apdus","offset","isFirst","maxChunkSize","hasMore","chunkSize","apdu","copy","push","handleAuthTokenResponse"],"mappings":"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","sourcesContent":["//@flow\n\nimport type Transport from \"@ledgerhq/hw-transport\";\n\nconst SIGN_RAW_TX_INS = 0x04;\nconst SIGN_HASH_TX_INS = 0x07;\nconst SIGN_MESSAGE_INS = 0x06;\nconst GET_ADDRESS_AUTH_TOKEN_INS = 0x09;\n\nconst ACTIVE_SIGNERS = [\n    SIGN_RAW_TX_INS,\n    SIGN_HASH_TX_INS,\n    SIGN_MESSAGE_INS,\n    GET_ADDRESS_AUTH_TOKEN_INS\n];\n\nexport default class Elrond {\n    transport: Transport<*>;\n\n    constructor(transport: Transport<*>, scrambleKey: string = \"eGLD\") {\n        this.transport = transport;\n        transport.decorateAppAPIMethods(\n            this,\n            [\"getAddress\", \"setAddress\", \"signTransaction\", \"signMessage\", \"getAppConfiguration\", \"getAddressAndSignAuthToken\"],\n            scrambleKey\n        );\n    }\n\n    async getAddress(\n        account: number,\n        index: number,\n        display?: boolean,\n    ): Promise<{\n        publicKey: string,\n        address: string,\n        chainCode?: string,\n    }> {\n        const cla = 0xed;\n        const ins = 0x03;\n        const p1 = display ? 0x01 : 0x00;\n        const p2 = 0x00;\n        const data = Buffer.alloc(8);\n\n        data.writeInt32BE(account, 0);\n        data.writeUInt32BE(index, 4);\n\n        const response = await this.transport.send(cla, ins, p1, p2, data);\n\n        const addressLength = response[0];\n        const address = response.slice(1, 1 + addressLength).toString(\"ascii\");\n\n        return {address};\n    }\n\n    async setAddress(\n        account: number,\n        index: number,\n        display?: boolean,\n    ) {\n        const cla = 0xed;\n        const ins = 0x05;\n        const p1 = display ? 0x01 : 0x00;\n        const p2 = 0x00;\n        const data = Buffer.alloc(8);\n\n        data.writeInt32BE(account, 0);\n        data.writeUInt32BE(index, 4);\n\n        return await this.transport.send(cla, ins, p1, p2, data);\n    }\n\n    async signTransaction(\n        rawTx: Buffer,\n        usingHash: boolean,\n    ): Promise<string> {\n        return usingHash ? this.sign(rawTx, SIGN_HASH_TX_INS) :\n            this.sign(rawTx, SIGN_RAW_TX_INS);\n    }\n\n    async signMessage(message: Buffer): Promise<string> {\n        return this.sign(message, SIGN_MESSAGE_INS);\n    }\n\n    async getAddressAndSignAuthToken(\n        account: number,\n        index: number,\n        token: Buffer,\n    ): Promise<{\n        address: string,\n        signature: string,\n    }> {\n        const data = Buffer.alloc(12);\n\n        data.writeInt32BE(account, 0);\n        data.writeUInt32BE(index, 4);\n        data.writeUInt32BE(token.length, 8);\n\n        let buffersArray = [data, token];\n        let result = await this.sign(Buffer.concat(buffersArray), GET_ADDRESS_AUTH_TOKEN_INS);\n\n        let splitRes = result.split(\"|\");\n        return {\n            address: splitRes[0],\n            signature: splitRes[1]\n        }\n    }\n\n    async getAppConfiguration(): Promise<{\n        version: string,\n    }> {\n        const response = await this.transport.send(0xed, 0x02, 0x00, 0x00);\n        return {\n            contractData: response[0],\n            accountIndex: response[1],\n            addressIndex: response[2],\n            version: `${response[3]}.${response[4]}.${response[5]}`\n        }\n    }\n\n    async sign(message: Buffer, type: number): Promise<string> {\n        if (!ACTIVE_SIGNERS.includes(type)) {\n            throw new Error(`invalid sign instruction called: ${type}`);\n        }\n\n        const apdus = [];\n        let offset = 0;\n\n        while (offset !== message.length) {\n            const isFirst = offset === 0;\n            const maxChunkSize = 150;\n\n            const hasMore = offset + maxChunkSize < message.length;\n            const chunkSize = hasMore ? maxChunkSize : message.length - offset;\n\n            const apdu = {\n                cla: 0xed,\n                ins: type,\n                p1: isFirst ? 0x00 : 0x80,\n                p2: 0x00,\n                data: Buffer.alloc(chunkSize),\n            };\n\n            message.copy(apdu.data, 0, offset, offset + chunkSize);\n\n            apdus.push(apdu);\n            offset += chunkSize;\n        }\n\n        let response = Buffer.alloc(0);\n        for (let apdu of apdus) {\n            response = await this.transport.send(\n                apdu.cla,\n                apdu.ins,\n                apdu.p1,\n                apdu.p2,\n                apdu.data\n            );\n        }\n\n        if (GET_ADDRESS_AUTH_TOKEN_INS === type) {\n            return this.handleAuthTokenResponse(response);\n        }\n\n        if (response.length !== 67 || response[0] !== 64) {\n            throw new Error(\"invalid signature received from ledger device\")\n        }\n\n        return response.slice(1, response.length - 2).toString(\"hex\");\n    }\n\n    handleAuthTokenResponse(response: Buffer) : Promise<string> {\n        if (response.length !== 129 && response[0] !== 126) {\n            throw new Error(\"invalid address and token signature received from ledger device\")\n        }\n\n        const address = response.slice(1, 63).toString(\"ascii\");\n        const signature = response.slice(63, response.length - 2).toString(\"hex\");\n        return address + \"|\" + signature;\n    }\n}\n"],"file":"Elrond.js"}