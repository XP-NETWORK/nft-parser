'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.modifyFactory = exports.modifyProvider = void 0;
const web_1 = require("@ethersproject/web");
const ethers_1 = require("ethers");
const providers_1 = require("@ethersproject/providers");
const utils_1 = require("ethers/lib/utils");
const logger_1 = require("@ethersproject/logger");
const logger = new logger_1.Logger('web3-providers-connex/ethers');
const modifyProvider = (provider) => {
    provider.getTransaction = (transactionHash) => __awaiter(void 0, void 0, void 0, function* () {
        yield provider.getNetwork();
        transactionHash = yield transactionHash;
        const params = { transactionHash: provider.formatter.hash(transactionHash, true) };
        return (0, web_1.poll)(() => __awaiter(void 0, void 0, void 0, function* () {
            // const result = await provider.perform("getTransaction", params);
            const result = yield provider.send('eth_getTransactionByHash', [transactionHash]);
            if (result == null) {
                if (provider._emitted["t:" + transactionHash] == null) {
                    return null;
                }
                return undefined;
            }
            // const tx = provider.formatter.transactionResponse(result);
            if (result.to == null && result.creates == null) {
                // transaction.creates = this.contractAddress(transaction);
                const receipt = yield provider.send('eth_getTransactionReceipt', [transactionHash]);
                result.creates = receipt.contractAddress;
            }
            const tx = transactionResponse(provider, result);
            if (tx.blockNumber == null) {
                tx.confirmations = 0;
            }
            else if (tx.confirmations == null) {
                const blockNumber = yield provider._getInternalBlockNumber(100 + 2 * provider.pollingInterval);
                // Add the confirmations using the fast block number (pessimistic)
                let confirmations = (blockNumber - tx.blockNumber) + 1;
                if (confirmations <= 0) {
                    confirmations = 1;
                }
                tx.confirmations = confirmations;
            }
            return provider._wrapTransaction(tx);
        }), { oncePoll: this });
    });
    const transactionResponse = (provider, transaction) => {
        // Rename gas to gasLimit
        if (transaction.gas != null && transaction.gasLimit == null) {
            transaction.gasLimit = transaction.gas;
        }
        // Some clients (TestRPC) do strange things like return 0x0 for the
        // 0 address; correct this to be a real address
        if (transaction.to && ethers_1.BigNumber.from(transaction.to).isZero()) {
            transaction.to = "0x0000000000000000000000000000000000000000";
        }
        // Rename input to data
        if (transaction.input != null && transaction.data == null) {
            transaction.data = transaction.input;
        }
        // // If to and creates are empty, populate the creates from the transaction
        // if (transaction.to == null && transaction.creates == null) {
        // 	transaction.creates = this.contractAddress(transaction);
        // }
        if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {
            transaction.accessList = [];
        }
        const result = providers_1.Formatter.check(provider.formatter.formats.transaction, transaction);
        if (transaction.chainId != null) {
            let chainId = transaction.chainId;
            if ((0, utils_1.isHexString)(chainId)) {
                chainId = ethers_1.BigNumber.from(chainId).toNumber();
            }
            result.chainId = chainId;
        }
        else {
            let chainId = transaction.networkId;
            // geth-etc returns chainId
            if (chainId == null && result.v == null) {
                chainId = transaction.chainId;
            }
            if ((0, utils_1.isHexString)(chainId)) {
                chainId = ethers_1.BigNumber.from(chainId).toNumber();
            }
            if (typeof (chainId) !== "number" && result.v != null) {
                chainId = (result.v - 35) / 2;
                if (chainId < 0) {
                    chainId = 0;
                }
                chainId = parseInt(chainId);
            }
            if (typeof (chainId) !== "number") {
                chainId = 0;
            }
            result.chainId = chainId;
        }
        // // 0x0000... should actually be null
        // if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
        // 	result.blockHash = null;
        // }
        return result;
    };
    return provider;
};
exports.modifyProvider = modifyProvider;
const modifyFactory = (factory) => {
    factory.deploy = (...args) => __awaiter(void 0, void 0, void 0, function* () {
        let overrides = {};
        // If 1 extra parameter was passed in, it contains overrides
        if (args.length === factory.interface.deploy.inputs.length + 1) {
            overrides = args.pop();
        }
        // Make sure the call matches the constructor signature
        logger.checkArgumentCount(args.length, factory.interface.deploy.inputs.length, " in Contract constructor");
        // Resolve ENS names and promises in the arguments
        const params = yield resolveAddresses(factory.signer, args, factory.interface.deploy.inputs);
        params.push(overrides);
        // Get the deployment transaction (with optional overrides)
        const unsignedTx = factory.getDeployTransaction(...params);
        // Send the deployment transaction
        const tx = yield factory.signer.sendTransaction(unsignedTx);
        // const address = getStatic<(tx: TransactionResponse) => string>(this.constructor, "getContractAddress")(tx);
        const address = tx.creates;
        const contract = (0, utils_1.getStatic)(factory.constructor, "getContract")(address, factory.interface, factory.signer);
        // Add the modified wait that wraps events
        addContractWait(contract, tx);
        (0, utils_1.defineReadOnly)(contract, "deployTransaction", tx);
        return contract;
    });
    const resolveAddresses = (resolver, value, paramType) => __awaiter(void 0, void 0, void 0, function* () {
        if (Array.isArray(paramType)) {
            return yield Promise.all(paramType.map((paramType, index) => {
                return resolveAddresses(resolver, ((Array.isArray(value)) ? value[index] : value[paramType.name]), paramType);
            }));
        }
        if (paramType.type === "address") {
            return yield resolveName(resolver, value);
        }
        if (paramType.type === "tuple") {
            return yield resolveAddresses(resolver, value, paramType.components);
        }
        if (paramType.baseType === "array") {
            if (!Array.isArray(value)) {
                return Promise.reject(logger.makeError("invalid value for array", logger_1.Logger.errors.INVALID_ARGUMENT, {
                    argument: "value",
                    value
                }));
            }
            return yield Promise.all(value.map((v) => resolveAddresses(resolver, v, paramType.arrayChildren)));
        }
        return value;
    });
    const resolveName = (resolver, nameOrPromise) => __awaiter(void 0, void 0, void 0, function* () {
        const name = yield nameOrPromise;
        if (typeof (name) !== "string") {
            logger.throwArgumentError("invalid address or ENS name", "name", name);
        }
        // If it is already an address, just use it (after adding checksum)
        try {
            return (0, utils_1.getAddress)(name);
        }
        catch (error) { }
        if (!resolver) {
            logger.throwError("a provider or signer is needed to resolve ENS names", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "resolveName"
            });
        }
        const address = yield resolver.resolveName(name);
        if (address == null) {
            logger.throwArgumentError("resolver or addr is not configured for ENS name", "name", name);
        }
        return address;
    });
    const addContractWait = (contract, tx) => {
        const wait = tx.wait.bind(tx);
        tx.wait = (confirmations) => {
            return wait(confirmations).then((receipt) => {
                receipt.events = receipt.logs.map((log) => {
                    let event = (0, utils_1.deepCopy)(log);
                    let parsed = null;
                    try {
                        parsed = contract.interface.parseLog(log);
                    }
                    catch (e) { }
                    // Successfully parsed the event log; include it
                    if (parsed) {
                        event.args = parsed.args;
                        event.decode = (data, topics) => {
                            if (!!parsed) {
                                return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);
                            }
                        };
                        event.event = parsed.name;
                        event.eventSignature = parsed.signature;
                    }
                    // Useful operations
                    event.removeListener = () => { return contract.provider; };
                    event.getBlock = () => {
                        return contract.provider.getBlock(receipt.blockHash);
                    };
                    event.getTransaction = () => {
                        return contract.provider.getTransaction(receipt.transactionHash);
                    };
                    event.getTransactionReceipt = () => {
                        return Promise.resolve(receipt);
                    };
                    return event;
                });
                return receipt;
            });
        };
    };
    return factory;
};
exports.modifyFactory = modifyFactory;
//# sourceMappingURL=ethers.js.map