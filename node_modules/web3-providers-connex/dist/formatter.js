'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Formatter = void 0;
const utils_1 = require("./utils");
const error_1 = require("./error");
const web3_utils_1 = __importDefault(require("web3-utils"));
class Formatter {
    constructor(connex, ifSetNet) {
        this._inputFormatters = {};
        this.formatInput = (payload) => {
            const inputFormatter = this._inputFormatters[payload.method];
            if (!inputFormatter) {
                return payload.params;
            }
            return inputFormatter(payload);
        };
        this._getBlockByNumber = (payload) => {
            const num = (0, utils_1.parseBlockNumber)(payload.params[0]);
            if (num === null) {
                return error_1.Err.ArgumentMissingOrInvalid('eth_getBlockByNumber', 'blockNumber');
            }
            // payload.params[0] = num;
            return [num];
        };
        this._getBalance = (payload) => {
            const params = payload.params.map(x => x);
            if (!this._ifSetNet) {
                if (params.length == 2 &&
                    !(typeof params[1] === 'string' && params[1] === 'latest')) {
                    return error_1.Err.MethodParamNotSupported('eth_getBalance', 2);
                }
            }
            else if (typeof params[1] !== 'number') {
                const revision = (0, utils_1.parseBlockNumber)(params[1] || 'latest');
                if (revision === null) {
                    return error_1.Err.ArgumentMissingOrInvalid('eth_getBalance', 'revision');
                }
                params[1] = revision;
            }
            return params;
        };
        this._getCode = (payload) => {
            const params = payload.params.map(x => x);
            if (!this._ifSetNet) {
                if (params.length >= 2 &&
                    !(typeof params[1] === 'string' && params[1] === 'latest')) {
                    return error_1.Err.MethodParamNotSupported('eth_getCode', 2);
                }
            }
            else if (typeof params[1] !== 'number') {
                const revision = (0, utils_1.parseBlockNumber)(params[1] || 'latest');
                if (revision === null) {
                    return error_1.Err.ArgumentMissingOrInvalid('eth_getCode', 'revision');
                }
                params[1] = revision;
            }
            return params;
        };
        this._getStorageAt = (payload) => {
            const params = payload.params.map(x => x);
            if (!this._ifSetNet) {
                if (params.length >= 3 &&
                    !(typeof params[2] === 'string' && params[2] === 'latest')) {
                    return error_1.Err.MethodParamNotSupported('eth_getStorageAt', 3);
                }
            }
            else if (typeof params[1] !== 'number') {
                const revision = (0, utils_1.parseBlockNumber)(payload.params[2] || 'latest');
                if (revision === null) {
                    return error_1.Err.ArgumentMissingOrInvalid('eth_getStorageAt', 'revision');
                }
                params[2] = revision;
            }
            params[1] = (0, utils_1.toBytes32)(params[1]);
            return params;
        };
        this._sendTransaction = (payload) => {
            const o1 = payload.params[0];
            const o2 = {
                clauses: [{
                        to: !!o1.to ? o1.to : null,
                        value: !!o1.value ? o1.value : 0,
                        data: !!o1.data ? o1.data : '0x',
                    }],
                gas: !!o1.gas ? (0, utils_1.hexToNumber)(o1.gas) : undefined,
                from: o1.from,
            };
            return [o2];
        };
        this._call = (payload) => {
            const params = payload.params.map(x => x);
            if (!this._ifSetNet) {
                if (params.length >= 2 &&
                    !(typeof params[1] === 'string' && params[1] === 'latest')) {
                    return error_1.Err.MethodParamNotSupported('eth_call', 2);
                }
            }
            else if (typeof params[1] !== 'number') {
                const revision = (0, utils_1.parseBlockNumber)(params[1] || 'latest');
                if (revision == null) {
                    return error_1.Err.ArgumentMissingOrInvalid('eth_call', 'revision');
                }
                params[1] = revision;
            }
            params[0] = this._sendTransaction({
                id: payload.id,
                method: payload.method,
                params: params
            })[0];
            return params;
        };
        this._estimateGas = (payload) => {
            return this._sendTransaction(payload);
        };
        this._getLogs = (payload) => {
            const args = payload.params[0];
            let fromBlock, toBlock;
            if (!args.fromBlock) {
                fromBlock = this._connex.thor.status.head.number; // fromBlock default set to latest
            }
            else {
                let test = (0, utils_1.parseBlockNumber)(args.fromBlock);
                if (test === undefined) {
                    test = this._connex.thor.status.head.number;
                }
                else if (typeof test !== 'number') {
                    return error_1.Err.ArgumentMissingOrInvalid('eth_getPastLog', 'options.fromBlock');
                }
                fromBlock = test;
            }
            if (!args.toBlock) {
                toBlock = this._connex.thor.status.head.number; // toBlock default set to latest
            }
            else {
                let test = (0, utils_1.parseBlockNumber)(args.toBlock);
                if (test === undefined) {
                    test = this._connex.thor.status.head.number;
                }
                else if (typeof test !== 'number') {
                    return error_1.Err.ArgumentMissingOrInvalid('eth_getPastLog', 'options.toBlock');
                }
                toBlock = test;
            }
            const out = {
                range: {
                    unit: 'block',
                    from: fromBlock,
                    to: toBlock,
                },
                criteria: (0, utils_1.toFilterCriteria)(args),
            };
            return [out];
        };
        this._subscribe = (payload) => {
            const name = payload.params[0];
            switch (name) {
                case 'newHeads':
                    return ['newHeads'];
                case 'logs':
                    return ['logs', (0, utils_1.toFilterCriteria)(payload.params[1])];
                default:
                    return error_1.Err.InvalidSubscriptionName(name);
            }
        };
        this._sendRawTransaction = function (payload) {
            const raw = payload.params[0];
            if (!web3_utils_1.default.isHexStrict(raw)) {
                return error_1.Err.ArgumentMissingOrInvalid('eth_sendRawTransaction', 'raw');
            }
            return [raw];
        };
        this.outputReceiptFormatter = function toRetReceipt(receipt) {
            const logs = (receipt.outputs.length > 0 && receipt.outputs[0].events.length > 0) ?
                receipt.outputs[0].events.map(event => {
                    return {
                        blockHash: receipt.meta.blockID,
                        blockNumber: receipt.meta.blockNumber,
                        transactionHash: receipt.meta.txID,
                        address: event.address,
                        topics: event.topics.map((x) => x),
                        data: event.data,
                        transactionIndex: -1,
                        logIndex: -1,
                    };
                }) : [];
            return {
                status: !receipt.reverted ? '0x1' : '0x0',
                blockHash: receipt.meta.blockID,
                blockNumber: receipt.meta.blockNumber,
                transactionHash: receipt.meta.txID,
                gasUsed: receipt.gasUsed,
                transactionIndex: -1,
                cumulativeGasUsed: -1,
                effectiveGasPrice: null,
                logsBloom: null,
                from: null,
                to: null,
                contractAddress: (receipt.outputs.length && receipt.outputs[0].contractAddress) ? receipt.outputs[0].contractAddress : undefined,
                logs: logs,
                thor: receipt,
            };
        };
        this.outputBlockFormatter = function (b) {
            return {
                hash: b.id,
                parentHash: b.parentID,
                number: b.number,
                size: b.size,
                stateRoot: b.stateRoot,
                receiptsRoot: b.receiptsRoot,
                transactionRoot: b.txsRoot,
                timestamp: b.timestamp,
                gasLimit: b.gasLimit,
                gasUsed: b.gasUsed,
                transactions: b.transactions,
                miner: b.signer,
                extraData: '0x',
                // incompatible fields
                difficulty: null,
                totalDifficulty: null,
                uncles: null,
                sha3Uncles: null,
                nonce: null,
                logsBloom: null,
                // original block returned by connex
                thor: b,
            };
        };
        this.outputHeaderFormatter = (b) => {
            return {
                hash: b.id,
                parentHash: b.parentID,
                number: b.number,
                stateRoot: b.stateRoot,
                receiptsRoot: b.receiptsRoot,
                transactionRoot: b.txsRoot,
                timestamp: b.timestamp,
                gasLimit: b.gasLimit,
                gasUsed: b.gasUsed,
                miner: b.signer,
                // unsupported
                nonce: null,
                sha3Uncles: null,
                logsBloom: null,
                extraData: null,
            };
        };
        this._connex = connex;
        this._ifSetNet = ifSetNet;
        this._inputFormatters['eth_getBlockByNumber'] = this._getBlockByNumber;
        this._inputFormatters['eth_getBalance'] = this._getBalance;
        this._inputFormatters['eth_getCode'] = this._getCode;
        this._inputFormatters['eth_getStorageAt'] = this._getStorageAt;
        this._inputFormatters['eth_sendTransaction'] = this._sendTransaction;
        this._inputFormatters['eth_call'] = this._call;
        this._inputFormatters['eth_estimateGas'] = this._estimateGas;
        this._inputFormatters['eth_getLogs'] = this._getLogs;
        this._inputFormatters['eth_subscribe'] = this._subscribe;
        this._inputFormatters['eth_sendRawTransaction'] = this._sendRawTransaction;
    }
    outputTransactionFormatter(tx) {
        return {
            hash: tx.id,
            blockNumber: tx.meta.blockNumber,
            blockHash: tx.meta.blockID,
            from: tx.origin,
            to: tx.clauses[0].to,
            input: tx.clauses[0].data,
            value: tx.clauses[0].value,
            gas: tx.gas,
            transactionIndex: null,
            // incompatible fields
            nonce: -1,
            gasPrice: null,
            thor: tx,
        };
    }
    outputLogsFormatter(ret) {
        return ret.map((ret) => {
            return {
                address: ret.address,
                topics: ret.topics,
                data: ret.data,
                blockHash: ret.meta.blockID,
                blockNumber: ret.meta.blockNumber,
                transactionHash: ret.meta.txID,
                transactionIndex: -1,
                logIndex: -1,
            };
        });
    }
}
exports.Formatter = Formatter;
//# sourceMappingURL=formatter.js.map