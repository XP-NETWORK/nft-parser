/// <reference types="@vechain/connex-types">
'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnexProvider = void 0;
const utils_1 = require("./utils");
const error_1 = require("./error");
const formatter_1 = require("./formatter");
const thor_devkit_1 = require("thor-devkit");
const eventemitter3_1 = __importDefault(require("eventemitter3"));
const restful_1 = require("./restful");
class ConnexProvider extends eventemitter3_1.default {
    constructor(opt) {
        super();
        this._methodMap = {};
        this._subscriptions = {
            newHeads: {},
            logs: {},
        };
        this._next = (params) => __awaiter(this, void 0, void 0, function* () {
            const ticker = this.connex.thor.ticker();
            yield ticker.next();
            return true;
        });
        this._accounts = (params) => __awaiter(this, void 0, void 0, function* () {
            if (!this.wallet) {
                return [];
            }
            return this.wallet.list.map(key => key.address);
        });
        this._sendRawTransaction = (params) => __awaiter(this, void 0, void 0, function* () {
            try {
                if (this.restful) {
                    return this.restful.sendRawTransaction(params[0]);
                }
                return null;
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
        this._subscribe = (params) => __awaiter(this, void 0, void 0, function* () {
            const subId = this._getSubscriptionId(params);
            const subName = params[0];
            if (this._subscriptions[subName][subId]) {
                return Promise.reject(error_1.Err.SubscriptionAlreadyExist(subId));
            }
            this._subscriptions[subName][subId] = params[1] || {};
            return subId;
        });
        this._unsubscribe = (params) => __awaiter(this, void 0, void 0, function* () {
            const subId = params[0];
            if (!this._subscriptions['newHeads'][subId] && !this._subscriptions['logs'][subId]) {
                return Promise.reject(error_1.Err.SubscriptionIdNotFound);
            }
            this._subscriptions['newHeads'][subId] ?
                delete this._subscriptions['newHeads'][subId] :
                delete this._subscriptions['logs'][subId];
            return true;
        });
        this._subLoop = () => __awaiter(this, void 0, void 0, function* () {
            const ticker = this.connex.thor.ticker();
            try {
                for (;;) {
                    const best = yield ticker.next();
                    const newHeadsKeys = Object.keys(this._subscriptions['newHeads']);
                    if (newHeadsKeys.length > 0) {
                        (() => __awaiter(this, void 0, void 0, function* () {
                            try {
                                const blk = yield this.connex.thor.block().get();
                                if (blk) {
                                    newHeadsKeys.forEach(key => {
                                        this.emit('message', (0, utils_1.toEip1193SubResp)(this._formatter.outputHeaderFormatter(blk), key));
                                    });
                                }
                            }
                            catch (_a) { }
                        }))();
                    }
                    const logsKeys = Object.keys(this._subscriptions['logs']);
                    if (logsKeys.length > 0) {
                        logsKeys.forEach((key) => __awaiter(this, void 0, void 0, function* () {
                            const MAX_LIMIT = 256;
                            const range = {
                                unit: 'block',
                                from: best.number,
                                to: best.number,
                            };
                            try {
                                const ret = yield this.connex.thor.filter('event', this._subscriptions['logs'][key])
                                    .range(range)
                                    .apply(0, MAX_LIMIT);
                                if (ret) {
                                    this.emit('message', (0, utils_1.toEip1193SubResp)(this._formatter.outputLogsFormatter(ret), key));
                                }
                            }
                            catch (_b) { }
                        }));
                    }
                }
            }
            catch (err) {
                throw new Error(err);
            }
        });
        this._getSubscriptionId = (params) => {
            return '0x' + (0, thor_devkit_1.keccak256)((new Date()).getTime().toString(), JSON.stringify(params)).toString('hex');
        };
        this._getLogs = (params) => __awaiter(this, void 0, void 0, function* () {
            const MAX_LIMIT = 256;
            const opts = params[0];
            try {
                const ret = yield this.connex.thor.filter('event', opts.criteria)
                    .range(opts.range)
                    .apply(0, MAX_LIMIT);
                return this._formatter.outputLogsFormatter(ret);
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
        this._estimateGas = (params) => __awaiter(this, void 0, void 0, function* () {
            const txObj = params[0];
            let explainer = this.connex.thor.explain([txObj.clauses[0]]);
            if (txObj.from) {
                explainer = explainer.caller(txObj.from);
            }
            if (txObj.gas) {
                explainer = explainer.gas(txObj.gas);
            }
            try {
                const outputs = yield explainer.execute();
                const output = outputs[0];
                if (output.reverted) {
                    return Promise.reject({
                        data: (0, utils_1.getErrMsg)(output),
                        message: (output === null || output === void 0 ? void 0 : output.revertReason) || output.vmError
                    });
                }
                const clause = {
                    to: txObj.clauses[0].to,
                    value: txObj.clauses[0].value,
                    data: txObj.clauses[0].data ? txObj.clauses[0].data : '0x',
                };
                const execGas = outputs.reduce((sum, out) => sum + out.gasUsed, 0);
                const intrinsicGas = thor_devkit_1.Transaction.intrinsicGas([clause]);
                const estimatedGas = intrinsicGas + (execGas ? (execGas + 15000) : 0);
                return estimatedGas;
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
        this._call = (params) => __awaiter(this, void 0, void 0, function* () {
            const txObj = params[0];
            try {
                if (this.restful) {
                    const callObj = {
                        clauses: txObj.clauses.map(c => {
                            return {
                                to: c.to,
                                value: '' + c.value,
                                data: c.data || '0x'
                            };
                        })
                    };
                    if (txObj.gas) {
                        callObj.gas = txObj.gas;
                    }
                    if (txObj.from) {
                        callObj.caller = txObj.from;
                    }
                    return this.restful.call(callObj, params[1]);
                }
                let explainer = this.connex.thor.explain([txObj.clauses[0]]);
                if (txObj.from) {
                    explainer = explainer.caller(txObj.from);
                }
                if (txObj.gas) {
                    explainer = explainer.gas(txObj.gas);
                }
                const outputs = yield explainer.execute();
                const output = outputs[0];
                if (output.reverted) {
                    return Promise.reject({
                        data: (0, utils_1.getErrMsg)(output),
                        message: (output === null || output === void 0 ? void 0 : output.revertReason) || output.vmError
                    });
                }
                return output.data;
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
        this._gasPrice = (params) => __awaiter(this, void 0, void 0, function* () {
            return 0;
        });
        this._sendTransaction = (params) => __awaiter(this, void 0, void 0, function* () {
            const txObj = params[0];
            let ss = this.connex.vendor.sign('tx', [txObj.clauses[0]]);
            if (txObj.from) {
                ss = ss.signer(txObj.from);
            }
            if (txObj.gas) {
                ss = ss.gas(txObj.gas);
            }
            try {
                const ret = yield ss.request();
                return ret.txid;
            }
            catch (err) {
                return Promise.reject(err);
            }
            ;
        });
        this._getStorageAt = (params) => __awaiter(this, void 0, void 0, function* () {
            try {
                if (this.restful) {
                    return this.restful.getStorageAt(params[0], params[1], params[2]);
                }
                const storage = yield this.connex.thor.account(params[0]).getStorage(params[1]);
                return storage.value;
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
        this._getTransactionReceipt = (params) => __awaiter(this, void 0, void 0, function* () {
            const hash = params[0];
            try {
                const receipt = yield this.connex.thor.transaction(hash).getReceipt();
                if (!receipt) {
                    return null;
                }
                else {
                    return this._formatter.outputReceiptFormatter(receipt);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
            ;
        });
        this._isSyncing = (params) => __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.connex.thor.ticker().next();
                if (this.connex.thor.status.progress == 1) {
                    return false;
                }
                else {
                    const highestBlock = Math.floor((Date.now() - this.connex.thor.genesis.timestamp) / 10000);
                    return {
                        startingBlock: null,
                        currentBlock: this.connex.thor.status.head.number,
                        highestBlock: highestBlock,
                        thor: this.connex.thor.status,
                    };
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
        this._getCode = (params) => __awaiter(this, void 0, void 0, function* () {
            try {
                if (this.restful) {
                    return this.restful.getCode(params[0], params[1]);
                }
                const code = yield this.connex.thor.account(params[0]).getCode();
                return code.code;
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
        this._getBlockNumber = (params) => __awaiter(this, void 0, void 0, function* () {
            try {
                const blk = yield this.connex.thor.block().get();
                if (!blk) {
                    return null;
                }
                else {
                    return blk.number;
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
        this._getBalance = (params) => __awaiter(this, void 0, void 0, function* () {
            try {
                if (this.restful) {
                    return this.restful.getBalance(params[0], params[1]);
                }
                const acc = yield this.connex.thor.account(params[0]).get();
                return acc.balance;
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
        this._getTransactionByHash = (params) => __awaiter(this, void 0, void 0, function* () {
            const hash = params[0];
            try {
                const tx = yield this.connex.thor.transaction(hash).get();
                if (!tx) {
                    return null;
                }
                else {
                    return this._formatter.outputTransactionFormatter(tx);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
        this._getChainId = (params) => __awaiter(this, void 0, void 0, function* () {
            return this.chainTag;
        });
        this._getBlockByNumber = (params) => __awaiter(this, void 0, void 0, function* () {
            const num = params[0];
            try {
                const blk = yield this.connex.thor.block(num).get();
                if (!blk) {
                    return null; //Promise.reject(Err.BlockNotFound(num ? (num == 0 ? 'earliest' : num) : 'latest'));
                }
                else {
                    return this._formatter.outputBlockFormatter(blk);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
        this._getBlockByHash = (params) => __awaiter(this, void 0, void 0, function* () {
            const hash = params[0];
            try {
                const blk = yield this.connex.thor.block(hash).get();
                if (!blk) {
                    return null;
                }
                else {
                    return this._formatter.outputBlockFormatter(blk);
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
        this.connex = opt.connex;
        const id = opt.connex.thor.genesis.id;
        this.chainTag = (0, utils_1.hexToNumber)('0x' + id.substring(id.length - 2));
        this._formatter = new formatter_1.Formatter(opt.connex, !!opt.net);
        this._methodMap['eth_getBlockByHash'] = this._getBlockByHash;
        this._methodMap['eth_getBlockByNumber'] = this._getBlockByNumber;
        this._methodMap['eth_chainId'] = this._getChainId;
        this._methodMap['eth_getTransactionByHash'] = this._getTransactionByHash;
        this._methodMap['eth_getBalance'] = this._getBalance;
        this._methodMap['eth_blockNumber'] = this._getBlockNumber;
        this._methodMap['eth_getCode'] = this._getCode;
        this._methodMap['eth_syncing'] = this._isSyncing;
        this._methodMap['eth_getTransactionReceipt'] = this._getTransactionReceipt;
        this._methodMap['eth_getStorageAt'] = this._getStorageAt;
        this._methodMap['eth_sendTransaction'] = this._sendTransaction;
        this._methodMap['eth_call'] = this._call;
        this._methodMap['eth_estimateGas'] = this._estimateGas;
        this._methodMap['eth_getLogs'] = this._getLogs;
        this._methodMap['eth_subscribe'] = this._subscribe;
        this._methodMap['eth_unsubscribe'] = this._unsubscribe;
        if (opt.net) {
            this.restful = new restful_1.Restful(opt.net, this.connex.thor.genesis.id);
            this._methodMap['eth_sendRawTransaction'] = this._sendRawTransaction;
        }
        if (opt.wallet) {
            this.wallet = opt.wallet,
                this._methodMap['eth_accounts'] = this._accounts;
        }
        // dummy
        this._methodMap['eth_gasPrice'] = this._gasPrice;
        this._subLoop();
        // Thor methods
        this._methodMap['thor_next'] = this._next;
    }
    request(req) {
        return __awaiter(this, void 0, void 0, function* () {
            const exec = this._methodMap[req.method];
            if (!exec) {
                return Promise.reject(error_1.Err.MethodNotFound(req.method));
            }
            const paramsOrErr = this._formatter.formatInput({
                id: req.id,
                method: req.method,
                params: req.params || [],
            });
            if (paramsOrErr instanceof Error) {
                return Promise.reject(paramsOrErr);
            }
            return exec(paramsOrErr);
        });
    }
}
exports.ConnexProvider = ConnexProvider;
//# sourceMappingURL=provider.js.map