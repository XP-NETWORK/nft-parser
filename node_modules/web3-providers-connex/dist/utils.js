'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeRevertReason = exports.signTransaction = exports.wait = exports.toFilterCriteria = exports.getErrMsg = exports.randAddr = exports.toHex = exports.hexToNumber = exports.toBytes32 = exports.parseBlockNumber = exports.toEip1193SubResp = void 0;
// import { JsonRpcResponse } from 'web3-core-helpers'
const crypto_1 = require("crypto");
const web3_utils_1 = __importDefault(require("web3-utils"));
const thor_devkit_1 = require("thor-devkit");
const thor_devkit_2 = require("thor-devkit");
const toEip1193SubResp = function (ret, id) {
    return {
        jsonrpc: '2.0',
        type: 'eth_subscription',
        data: {
            subscription: id,
            result: ret,
        }
    };
};
exports.toEip1193SubResp = toEip1193SubResp;
/**
 * Convert the input into either block id or block number compatible with connex.thor.block()
 * @param {hex | 'earliest' | 'latest' } input
 * @returns {string | number | null | undefined} Return null not recognized and undefined if input === 'latest'
 */
function parseBlockNumber(input) {
    // Return block id;
    if (web3_utils_1.default.isHexStrict(input) && input.length == 66) {
        return input;
    }
    // Convert block number;
    if (web3_utils_1.default.isHexStrict(input)) {
        return web3_utils_1.default.hexToNumber(input);
    }
    else if (input === 'earliest') {
        return 0;
    }
    else if (input === 'latest') {
        return undefined;
    }
    return null;
}
exports.parseBlockNumber = parseBlockNumber;
function toBytes32(hex) {
    return web3_utils_1.default.padLeft(hex, 64);
}
exports.toBytes32 = toBytes32;
function hexToNumber(hex) {
    return web3_utils_1.default.hexToNumber(hex);
}
exports.hexToNumber = hexToNumber;
function toHex(value) {
    return web3_utils_1.default.toHex(value);
}
exports.toHex = toHex;
function randAddr() {
    return '0x' + (0, crypto_1.randomBytes)(20).toString('hex');
}
exports.randAddr = randAddr;
function getErrMsg(output) {
    const errorSig = '0x08c379a0';
    let errMsg = (output === null || output === void 0 ? void 0 : output.revertReason) || output.vmError || output.data;
    if (!errMsg.startsWith('0x')) {
        // encode error message to allow sendTxCallback to decode later
        errMsg = thor_devkit_1.abi.encodeParameter('string', errMsg);
    }
    if (!errMsg.startsWith(errorSig)) {
        errMsg = errorSig + errMsg.slice(2);
    }
    return errMsg;
}
exports.getErrMsg = getErrMsg;
function toFilterCriteria(args) {
    const setCriteria = (address, topics) => {
        const c = {};
        if (address) {
            c.address = address;
        }
        ;
        if (topics) {
            if (topics[0]) {
                c.topic0 = topics[0];
            }
            if (topics[1]) {
                c.topic1 = topics[1];
            }
            if (topics[2]) {
                c.topic2 = topics[2];
            }
            if (topics[3]) {
                c.topic3 = topics[3];
            }
        }
        return c;
    };
    let ret = [];
    if (!(args.address && Array.isArray(args.address))
        && !(args.topics && args.topics[0] && Array.isArray(args.topics[0]))) {
        ret = [setCriteria(args.address, args.topics)];
    }
    else if (Array.isArray(args.address) || Array.isArray(args.topics)) {
        let len = 0;
        if (args.address) {
            len = args.address.length;
        }
        if (args.topics) {
            len = args.topics.length;
        }
        for (let i = 0; i < len; i++) {
            const addr = args.address ?
                (Array.isArray(args.address) ? args.address[i] : args.address) : undefined;
            const topics = args.topics ? args.topics[i] : undefined;
            ret.push(setCriteria(addr, topics));
        }
    }
    return ret;
}
exports.toFilterCriteria = toFilterCriteria;
const wait = (ms) => {
    return new Promise(resolve => {
        setTimeout(() => resolve(true), ms);
    });
};
exports.wait = wait;
/** params for tx construction */
const txParams = {
    expiration: 18,
    gasPriceCoef: 0
};
const signTransaction = (ethTx, wallet, provider) => __awaiter(void 0, void 0, void 0, function* () {
    if (wallet.list.length == 0) {
        return Promise.reject('Empty wallet');
    }
    const clauses = [{
            to: ethTx.to ? ethTx.to.toLowerCase() : null,
            value: ethTx.value ? ethTx.value : '0x0',
            data: ethTx.data ? ethTx.data : '0x',
        }];
    const gas = ethTx.gas || (yield provider.request({
        method: 'eth_estimateGas',
        params: [ethTx],
        jsonrpc: '2.0'
    }));
    const chainId = provider.chainTag;
    const best = yield provider.request({
        method: 'eth_getBlockByNumber',
        params: ['latest'],
        jsonrpc: '2.0'
    });
    const txBody = {
        chainTag: chainId,
        blockRef: best.hash.slice(0, 18),
        expiration: txParams.expiration,
        clauses,
        gasPriceCoef: txParams.gasPriceCoef,
        gas,
        dependsOn: null,
        nonce: '0x' + (0, crypto_1.randomBytes)(8).toString('hex')
    };
    const tx = new thor_devkit_2.Transaction(txBody);
    tx.signature = yield wallet.list[0].sign(tx.signingHash());
    return '0x' + tx.encode().toString('hex');
});
exports.signTransaction = signTransaction;
function decodeRevertReason(data) {
    const errorSig = '0x08c379a0';
    try {
        if (data.startsWith(errorSig)) {
            return thor_devkit_1.abi.decodeParameter('string', '0x' + data.slice(errorSig.length));
        }
        return '';
    }
    catch (_a) {
        return '';
    }
}
exports.decodeRevertReason = decodeRevertReason;
//# sourceMappingURL=utils.js.map