/** encode/decode parameters of contract function call, event log, according to ABI JSON */
export declare namespace abi {
    /**
     * encode single parameter
     * @param type type of the parameter
     * @param value value of the parameter
     * @returns encoded value in hex string
     */
    function encodeParameter(type: string, value: any): string;
    /**
     * decode single parameter
     * @param type type of the parameter
     * @param data encoded parameter in hex string
     * @returns decoded value
     */
    function decodeParameter(type: string, data: string): any;
    /**
     * encode a group of parameters
     * @param types type array
     * @param values value array
     * @returns encoded values in hex string
     */
    function encodeParameters(types: Function.Parameter[], values: any[]): string;
    /**
     * decode a group of parameters
     * @param types type array
     * @param data encoded values in hex string
     * @returns decoded object
     */
    function decodeParameters(types: Function.Parameter[], data: string): Decoded;
    /** for contract function */
    class Function {
        readonly definition: Function.Definition;
        /** canonical name */
        readonly canonicalName: string;
        /** the function signature, aka. 4 bytes prefix */
        readonly signature: string;
        /**
         * create a function object
         * @param definition abi definition of the function
         */
        constructor(definition: Function.Definition);
        /**
         * encode input parameters into call data
         * @param args arguments for the function
         */
        encode(...args: any[]): string;
        /**
         * decode output data
         * @param outputData output data to decode
         */
        decode(outputData: string): Decoded;
    }
    namespace Function {
        type StateMutability = 'pure' | 'view' | 'constant' | 'payable' | 'nonpayable';
        interface Parameter {
            name: string;
            type: string;
            components?: any[];
            internalType?: string;
        }
        interface Definition {
            type: 'function';
            name: string;
            constant?: boolean;
            payable?: boolean;
            stateMutability: StateMutability;
            inputs: Parameter[];
            outputs: Parameter[];
        }
    }
    /** for contract event */
    class Event {
        readonly definition: Event.Definition;
        /** canonical name */
        readonly canonicalName: string;
        /** the event signature */
        readonly signature: string;
        /** for contract event */
        constructor(definition: Event.Definition);
        /**
         * encode an object of indexed keys into topics.
         * @param indexed an object contains indexed keys
         */
        encode(indexed: object): Array<string | null>;
        /**
         * decode event log
         * @param data data in event output
         * @param topics topics in event
         */
        decode(data: string, topics: string[]): Decoded;
    }
    namespace Event {
        interface Parameter {
            name: string;
            type: string;
            indexed: boolean;
            components?: any[];
            internalType?: string;
        }
        interface Definition {
            type: 'event';
            name: string;
            anonymous?: boolean;
            inputs: Parameter[];
        }
    }
    type Decoded = {
        [name: string]: any;
    } & {
        [index: number]: any;
    };
}
