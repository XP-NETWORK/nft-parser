"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProxyNetworkProvider = void 0;
const axios_1 = __importDefault(require("axios"));
const account_1 = require("../account");
const constants_1 = require("../constants");
const errors_1 = require("../errors");
const logger_1 = require("../logger");
const networkConfig_1 = require("../networkConfig");
const networkStatus_1 = require("../networkStatus");
const transaction_1 = require("../transaction");
const contractResults_1 = require("./contractResults");
const tokens_1 = require("./tokens");
const transactions_1 = require("./transactions");
// TODO: Find & remove duplicate code between "ProxyNetworkProvider" and "ApiNetworkProvider".
class ProxyNetworkProvider {
    constructor(url, config) {
        this.url = url;
        this.config = Object.assign(Object.assign({}, constants_1.defaultConfig), config);
    }
    getNetworkConfig() {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doGetGeneric("network/config");
            let networkConfig = networkConfig_1.NetworkConfig.fromHttpResponse(response.config);
            return networkConfig;
        });
    }
    getNetworkStatus() {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doGetGeneric("network/status/4294967295");
            let networkStatus = networkStatus_1.NetworkStatus.fromHttpResponse(response.status);
            return networkStatus;
        });
    }
    getNetworkStakeStatistics() {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: Implement wrt.:
            // https://github.com/ElrondNetwork/api.elrond.com/blob/main/src/endpoints/stake/stake.service.ts
            throw new Error("Method not implemented.");
        });
    }
    getNetworkGeneralStatistics() {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: Implement wrt. (full implementation may not be possible):
            // https://github.com/ElrondNetwork/api.elrond.com/blob/main/src/endpoints/network/network.service.ts
            throw new Error("Method not implemented.");
        });
    }
    getAccount(address) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doGetGeneric(`address/${address.bech32()}`);
            let account = account_1.AccountOnNetwork.fromHttpResponse(response.account);
            return account;
        });
    }
    getFungibleTokensOfAccount(address, _pagination) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = `address/${address.bech32()}/esdt`;
            let response = yield this.doGetGeneric(url);
            let responseItems = Object.values(response.esdts);
            // Skip NFTs / SFTs.
            let responseItemsFiltered = responseItems.filter(item => !item.nonce);
            let tokens = responseItemsFiltered.map(item => tokens_1.FungibleTokenOfAccountOnNetwork.fromHttpResponse(item));
            // TODO: Fix sorting
            tokens.sort((a, b) => a.identifier.localeCompare(b.identifier));
            return tokens;
        });
    }
    getNonFungibleTokensOfAccount(address, _pagination) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = `address/${address.bech32()}/esdt`;
            let response = yield this.doGetGeneric(url);
            let responseItems = Object.values(response.esdts);
            // Skip fungible tokens.
            let responseItemsFiltered = responseItems.filter(item => item.nonce >= 0);
            let tokens = responseItemsFiltered.map(item => tokens_1.NonFungibleTokenOfAccountOnNetwork.fromProxyHttpResponse(item));
            // TODO: Fix sorting
            tokens.sort((a, b) => a.identifier.localeCompare(b.identifier));
            return tokens;
        });
    }
    getFungibleTokenOfAccount(address, tokenIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doGetGeneric(`address/${address.bech32()}/esdt/${tokenIdentifier}`);
            let tokenData = tokens_1.FungibleTokenOfAccountOnNetwork.fromHttpResponse(response.tokenData);
            return tokenData;
        });
    }
    getNonFungibleTokenOfAccount(address, collection, nonce) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doGetGeneric(`address/${address.bech32()}/nft/${collection}/nonce/${nonce.valueOf()}`);
            let tokenData = tokens_1.NonFungibleTokenOfAccountOnNetwork.fromProxyHttpResponseByNonce(response.tokenData);
            return tokenData;
        });
    }
    getTransaction(txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = this.buildUrlWithQueryParameters(`transaction/${txHash.toString()}`, { withResults: "true" });
            let response = yield this.doGetGeneric(url);
            let transaction = transactions_1.TransactionOnNetwork.fromProxyHttpResponse(txHash, response.transaction);
            return transaction;
        });
    }
    getTransactionStatus(txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doGetGeneric(`transaction/${txHash.toString()}/status`);
            let status = new transaction_1.TransactionStatus(response.status);
            return status;
        });
    }
    sendTransaction(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doPostGeneric("transaction/send", tx.toSendable());
            let hash = new transaction_1.TransactionHash(response.txHash);
            return hash;
        });
    }
    simulateTransaction(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doPostGeneric("transaction/simulate", tx.toSendable());
            return response;
        });
    }
    queryContract(query) {
        return __awaiter(this, void 0, void 0, function* () {
            let data = query.toHttpRequest();
            let response = yield this.doPostGeneric("vm-values/query", data);
            let queryResponse = contractResults_1.ContractQueryResponse.fromHttpResponse(response.data);
            return queryResponse;
        });
    }
    getDefinitionOfFungibleToken(_tokenIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: Implement wrt.:
            // https://github.com/ElrondNetwork/api.elrond.com/blob/main/src/endpoints/esdt/esdt.service.ts#L221
            throw new Error("Method not implemented.");
        });
    }
    getDefinitionOfTokenCollection(_collection) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: Implement wrt.:
            // https://github.com/ElrondNetwork/api.elrond.com/blob/main/src/endpoints/collections/collection.service.ts
            // https://docs.elrond.com/developers/esdt-tokens/#get-esdt-token-properties
            throw new Error("Method not implemented.");
        });
    }
    getNonFungibleToken(_collection, _nonce) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("Method not implemented.");
        });
    }
    doGetGeneric(resourceUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doGet(resourceUrl);
            return response;
        });
    }
    doPostGeneric(resourceUrl, payload) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doPost(resourceUrl, payload);
            return response;
        });
    }
    doGet(resourceUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let url = `${this.url}/${resourceUrl}`;
                let response = yield axios_1.default.get(url, this.config);
                let payload = response.data.data;
                return payload;
            }
            catch (error) {
                this.handleApiError(error, resourceUrl);
            }
        });
    }
    doPost(resourceUrl, payload) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let url = `${this.url}/${resourceUrl}`;
                let response = yield axios_1.default.post(url, payload, Object.assign(Object.assign({}, this.config), { headers: {
                        "Content-Type": "application/json",
                    } }));
                let responsePayload = response.data.data;
                return responsePayload;
            }
            catch (error) {
                this.handleApiError(error, resourceUrl);
            }
        });
    }
    buildUrlWithQueryParameters(endpoint, params) {
        let searchParams = new URLSearchParams();
        for (let [key, value] of Object.entries(params)) {
            if (value) {
                searchParams.append(key, value);
            }
        }
        return `${endpoint}?${searchParams.toString()}`;
    }
    handleApiError(error, resourceUrl) {
        if (!error.response) {
            logger_1.Logger.warn(error);
            throw new errors_1.ErrNetworkProvider(resourceUrl, error.toString(), error);
        }
        let errorData = error.response.data;
        let originalErrorMessage = errorData.error || errorData.message || JSON.stringify(errorData);
        throw new errors_1.ErrNetworkProvider(resourceUrl, originalErrorMessage, error);
    }
}
exports.ProxyNetworkProvider = ProxyNetworkProvider;
//# sourceMappingURL=proxyNetworkProvider.js.map