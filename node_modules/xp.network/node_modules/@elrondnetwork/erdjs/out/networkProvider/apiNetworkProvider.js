"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiNetworkProvider = void 0;
const axios_1 = __importDefault(require("axios"));
const account_1 = require("../account");
const constants_1 = require("../constants");
const errors_1 = require("../errors");
const interface_1 = require("./interface");
const logger_1 = require("../logger");
const networkStake_1 = require("../networkStake");
const stats_1 = require("../stats");
const transaction_1 = require("../transaction");
const contractResults_1 = require("./contractResults");
const proxyNetworkProvider_1 = require("./proxyNetworkProvider");
const tokenDefinitions_1 = require("./tokenDefinitions");
const tokens_1 = require("./tokens");
const transactions_1 = require("./transactions");
// TODO: Find & remove duplicate code between "ProxyNetworkProvider" and "ApiNetworkProvider".
class ApiNetworkProvider {
    constructor(url, config) {
        this.url = url;
        this.config = Object.assign(Object.assign({}, constants_1.defaultConfig), config);
        this.backingProxyNetworkProvider = new proxyNetworkProvider_1.ProxyNetworkProvider(url, config);
    }
    getNetworkConfig() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.backingProxyNetworkProvider.getNetworkConfig();
        });
    }
    getNetworkStatus() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.backingProxyNetworkProvider.getNetworkStatus();
        });
    }
    getNetworkStakeStatistics() {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doGetGeneric("stake");
            let networkStake = networkStake_1.NetworkStake.fromHttpResponse(response);
            return networkStake;
        });
    }
    getNetworkGeneralStatistics() {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doGetGeneric("stats");
            let stats = stats_1.Stats.fromHttpResponse(response);
            return stats;
        });
    }
    getAccount(address) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doGetGeneric(`accounts/${address.bech32()}`);
            let account = account_1.AccountOnNetwork.fromHttpResponse(response);
            return account;
        });
    }
    getFungibleTokensOfAccount(address, pagination) {
        return __awaiter(this, void 0, void 0, function* () {
            pagination = pagination || interface_1.Pagination.default();
            let url = `accounts/${address.bech32()}/tokens?${this.buildPaginationParams(pagination)}`;
            let response = yield this.doGetGeneric(url);
            let tokens = response.map(item => tokens_1.FungibleTokenOfAccountOnNetwork.fromHttpResponse(item));
            // TODO: Fix sorting
            tokens.sort((a, b) => a.identifier.localeCompare(b.identifier));
            return tokens;
        });
    }
    getNonFungibleTokensOfAccount(address, pagination) {
        return __awaiter(this, void 0, void 0, function* () {
            pagination = pagination || interface_1.Pagination.default();
            let url = `accounts/${address.bech32()}/nfts?${this.buildPaginationParams(pagination)}`;
            let response = yield this.doGetGeneric(url);
            let tokens = response.map(item => tokens_1.NonFungibleTokenOfAccountOnNetwork.fromApiHttpResponse(item));
            // TODO: Fix sorting
            tokens.sort((a, b) => a.identifier.localeCompare(b.identifier));
            return tokens;
        });
    }
    getFungibleTokenOfAccount(address, tokenIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doGetGeneric(`accounts/${address.bech32()}/tokens/${tokenIdentifier}`);
            let tokenData = tokens_1.FungibleTokenOfAccountOnNetwork.fromHttpResponse(response);
            return tokenData;
        });
    }
    getNonFungibleTokenOfAccount(address, collection, nonce) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doGetGeneric(`accounts/${address.bech32()}/nfts/${collection}-${nonce.hex()}`);
            let tokenData = tokens_1.NonFungibleTokenOfAccountOnNetwork.fromApiHttpResponse(response);
            return tokenData;
        });
    }
    getTransaction(txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doGetGeneric(`transactions/${txHash.toString()}`);
            let transaction = transactions_1.TransactionOnNetwork.fromApiHttpResponse(txHash, response);
            return transaction;
        });
    }
    getTransactionStatus(txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doGetGeneric(`transactions/${txHash.toString()}?fields=status`);
            let status = new transaction_1.TransactionStatus(response.status);
            return status;
        });
    }
    sendTransaction(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doPostGeneric("transactions", tx.toSendable());
            let hash = new transaction_1.TransactionHash(response.txHash);
            return hash;
        });
    }
    simulateTransaction(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.backingProxyNetworkProvider.simulateTransaction(tx);
        });
    }
    queryContract(query) {
        return __awaiter(this, void 0, void 0, function* () {
            let data = query.toHttpRequest();
            let response = yield this.doPostGeneric("query", data);
            let queryResponse = contractResults_1.ContractQueryResponse.fromHttpResponse(response);
            return queryResponse;
        });
    }
    getDefinitionOfFungibleToken(tokenIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doGetGeneric(`tokens/${tokenIdentifier}`);
            let definition = tokenDefinitions_1.DefinitionOfFungibleTokenOnNetwork.fromApiHttpResponse(response);
            return definition;
        });
    }
    getDefinitionOfTokenCollection(collection) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doGetGeneric(`collections/${collection}`);
            let definition = tokenDefinitions_1.DefinitionOfTokenCollectionOnNetwork.fromApiHttpResponse(response);
            return definition;
        });
    }
    getNonFungibleToken(collection, nonce) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doGetGeneric(`nfts/${collection}-${nonce.hex()}`);
            let token = tokens_1.NonFungibleTokenOfAccountOnNetwork.fromApiHttpResponse(response);
            return token;
        });
    }
    doGetGeneric(resourceUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doGet(resourceUrl);
            return response;
        });
    }
    doPostGeneric(resourceUrl, payload) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = yield this.doPost(resourceUrl, payload);
            return response;
        });
    }
    buildPaginationParams(pagination) {
        return `from=${pagination.from}&size=${pagination.size}`;
    }
    doGet(resourceUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let url = `${this.url}/${resourceUrl}`;
                let response = yield axios_1.default.get(url, this.config);
                return response.data;
            }
            catch (error) {
                this.handleApiError(error, resourceUrl);
            }
        });
    }
    doPost(resourceUrl, payload) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let url = `${this.url}/${resourceUrl}`;
                let response = yield axios_1.default.post(url, payload, Object.assign(Object.assign({}, this.config), { headers: {
                        "Content-Type": "application/json",
                    } }));
                let responsePayload = response.data;
                return responsePayload;
            }
            catch (error) {
                this.handleApiError(error, resourceUrl);
            }
        });
    }
    handleApiError(error, resourceUrl) {
        if (!error.response) {
            logger_1.Logger.warn(error);
            throw new errors_1.ErrNetworkProvider(resourceUrl, error.toString(), error);
        }
        let errorData = error.response.data;
        let originalErrorMessage = errorData.error || errorData.message || JSON.stringify(errorData);
        throw new errors_1.ErrNetworkProvider(resourceUrl, originalErrorMessage, error);
    }
}
exports.ApiNetworkProvider = ApiNetworkProvider;
//# sourceMappingURL=apiNetworkProvider.js.map