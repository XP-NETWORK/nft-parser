"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractQueryResponse = exports.ContractResultItem = exports.ContractResults = void 0;
const bignumber_js_1 = require("bignumber.js");
const address_1 = require("../address");
const balance_1 = require("../balance");
const hash_1 = require("../hash");
const networkParams_1 = require("../networkParams");
const nonce_1 = require("../nonce");
const smartcontracts_1 = require("../smartcontracts");
const transaction_1 = require("../transaction");
class ContractResults {
    constructor(items) {
        this.items = items;
        this.items.sort(function (a, b) {
            return a.nonce.valueOf() - b.nonce.valueOf();
        });
    }
    static empty() {
        return new ContractResults([]);
    }
    static fromProxyHttpResponse(results) {
        let items = results.map(item => ContractResultItem.fromProxyHttpResponse(item));
        return new ContractResults(items);
    }
    static fromApiHttpResponse(results) {
        let items = results.map(item => ContractResultItem.fromApiHttpResponse(item));
        return new ContractResults(items);
    }
}
exports.ContractResults = ContractResults;
class ContractResultItem {
    constructor() {
        this.hash = hash_1.Hash.empty();
        this.nonce = new nonce_1.Nonce(0);
        this.value = balance_1.Balance.Zero();
        this.receiver = new address_1.Address();
        this.sender = new address_1.Address();
        this.data = "";
        this.previousHash = hash_1.Hash.empty();
        this.originalHash = hash_1.Hash.empty();
        this.gasLimit = new networkParams_1.GasLimit(0);
        this.gasPrice = new networkParams_1.GasPrice(0);
        this.callType = 0;
        this.returnMessage = "";
    }
    static fromProxyHttpResponse(response) {
        let item = ContractResultItem.fromHttpResponse(response);
        return item;
    }
    static fromApiHttpResponse(response) {
        let item = ContractResultItem.fromHttpResponse(response);
        item.data = Buffer.from(item.data, "base64").toString();
        item.callType = Number(item.callType);
        return item;
    }
    static fromHttpResponse(response) {
        let item = new ContractResultItem();
        item.hash = new transaction_1.TransactionHash(response.hash);
        item.nonce = new nonce_1.Nonce(response.nonce || 0);
        item.value = balance_1.Balance.fromString(response.value);
        item.receiver = new address_1.Address(response.receiver);
        item.sender = new address_1.Address(response.sender);
        item.previousHash = new transaction_1.TransactionHash(response.prevTxHash);
        item.originalHash = new transaction_1.TransactionHash(response.originalTxHash);
        item.gasLimit = new networkParams_1.GasLimit(response.gasLimit);
        item.gasPrice = new networkParams_1.GasPrice(response.gasPrice);
        item.data = response.data || "";
        item.callType = response.callType;
        item.returnMessage = response.returnMessage;
        return item;
    }
    getOutputUntyped() {
        // TODO: Decide how to parse "data" (immediate results vs. other results).
        throw new Error("Method not implemented.");
    }
    getOutputTyped(_endpointDefinition) {
        // TODO: Decide how to parse "data" (immediate results vs. other results).
        throw new Error("Method not implemented.");
    }
}
exports.ContractResultItem = ContractResultItem;
class ContractQueryResponse {
    constructor() {
        this.returnData = [];
        this.returnCode = smartcontracts_1.ReturnCode.None;
        this.returnMessage = "";
        this.gasUsed = new networkParams_1.GasLimit(0);
    }
    static fromHttpResponse(payload) {
        let response = new ContractQueryResponse();
        let gasRemaining = new bignumber_js_1.BigNumber(payload["gasRemaining"] || payload["GasRemaining"] || 0);
        response.returnData = payload["returnData"] || [];
        response.returnCode = payload["returnCode"] || "";
        response.returnMessage = payload["returnMessage"] || "";
        response.gasUsed = new networkParams_1.GasLimit(smartcontracts_1.MaxUint64.minus(gasRemaining).toNumber());
        return response;
    }
    getOutputUntyped() {
        let buffers = this.returnData.map((item) => Buffer.from(item || "", "base64"));
        return buffers;
    }
    getOutputTyped(endpointDefinition) {
        let buffers = this.getOutputUntyped();
        let values = new smartcontracts_1.ArgSerializer().buffersToValues(buffers, endpointDefinition.output);
        return values;
    }
}
exports.ContractQueryResponse = ContractQueryResponse;
//# sourceMappingURL=contractResults.js.map