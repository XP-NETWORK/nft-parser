"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractAbstraction = exports.ContractView = exports.DEFAULT_SMART_CONTRACT_METHOD_NAME = void 0;
const michelson_encoder_1 = require("@taquito/michelson-encoder");
const constants_1 = require("../constants");
const contract_method_factory_1 = require("./contract-methods/contract-method-factory");
const errors_1 = require("./errors");
const lambda_view_1 = require("./lambda-view");
exports.DEFAULT_SMART_CONTRACT_METHOD_NAME = 'default';
/**
 * @description Utility class to retrieve data from a smart contract's storage without incurring fees via a contract's view method
 */
class ContractView {
    constructor(currentContract, provider, name, chainId, callbackParametersSchema, parameterSchema, args) {
        this.currentContract = currentContract;
        this.provider = provider;
        this.name = name;
        this.chainId = chainId;
        this.callbackParametersSchema = callbackParametersSchema;
        this.parameterSchema = parameterSchema;
        this.args = args;
    }
    /**
     *
     * @description Find which lambda contract to use based on the current network,
     * encode parameters to Michelson,
     * create an instance of Lambdaview to retrieve data, and
     * Decode Michelson response
     *
     * @param Options Address of a lambda contract (sandbox users)
     */
    read(customLambdaAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            let lambdaAddress;
            // TODO Verify if the 'customLambdaAdress' is a valid originated contract and if not, return an appropriate error message.  
            if (customLambdaAddress) {
                lambdaAddress = customLambdaAddress;
            }
            else if (this.chainId === constants_1.ChainIds.GRANADANET) {
                lambdaAddress = constants_1.DefaultLambdaAddresses.GRANADANET;
            }
            else if (this.chainId === constants_1.ChainIds.HANGZHOUNET) {
                lambdaAddress = constants_1.DefaultLambdaAddresses.HANGZHOUNET;
            }
            else if (this.chainId === constants_1.ChainIds.ITHACANET) {
                lambdaAddress = constants_1.DefaultLambdaAddresses.ITHACANET;
            }
            else if (this.chainId === constants_1.ChainIds.ITHACANET2) {
                lambdaAddress = constants_1.DefaultLambdaAddresses.ITHACANET2;
            }
            else if (this.chainId === constants_1.ChainIds.MAINNET) {
                lambdaAddress = constants_1.DefaultLambdaAddresses.MAINNET;
            }
            else {
                throw new errors_1.UndefinedLambdaContractError();
            }
            const lambdaContract = yield this.provider.at(lambdaAddress);
            const arg = this.parameterSchema.Encode(...this.args);
            const lambdaView = new lambda_view_1.default(lambdaContract, this.currentContract, this.name, arg);
            const failedWith = yield lambdaView.execute();
            const response = this.callbackParametersSchema.Execute(failedWith);
            return response;
        });
    }
}
exports.ContractView = ContractView;
const validateArgs = (args, schema, name) => {
    const sigs = schema.ExtractSignatures();
    if (!sigs.find((x) => x.length === args.length)) {
        throw new errors_1.InvalidParameterError(name, sigs, args);
    }
};
// lambda view tzip4
const isView = (entrypoint) => {
    let isView = false;
    if ('prim' in entrypoint && entrypoint.prim === 'pair' && entrypoint.args) {
        const lastElement = entrypoint.args[entrypoint.args.length - 1];
        if ('prim' in lastElement && lastElement.prim === 'contract') {
            isView = true;
        }
    }
    return isView;
};
const isContractProvider = (variableToCheck) => variableToCheck.contractProviderTypeSymbol !== undefined;
/**
 * @description Smart contract abstraction
 */
class ContractAbstraction {
    constructor(address, script, provider, storageProvider, entrypoints, chainId, rpc) {
        this.address = address;
        this.script = script;
        this.storageProvider = storageProvider;
        this.entrypoints = entrypoints;
        this.chainId = chainId;
        /**
         * @description Contains methods that are implemented by the target Tezos Smart Contract, and offers the user to call the Smart Contract methods as if they were native TS/JS methods.
         * NB: if the contract contains annotation it will include named properties; if not it will be indexed by a number.
         *
         */
        this.methods = {};
        /**
         * @description Contains methods that are implemented by the target Tezos Smart Contract, and offers the user to call the Smart Contract methods as if they were native TS/JS methods.
         * `methodsObject` serves the exact same purpose as the `methods` member. The difference is that it allows passing the parameter in an object format when calling the smart contract method (instead of the flattened representation)
         * NB: if the contract contains annotation it will include named properties; if not it will be indexed by a number.
         *
         */
        this.methodsObject = {};
        /**
         * @description Contains lamda views (tzip4) that are implemented by the target Tezos Smart Contract, and offers the user to call the lambda views as if they were native TS/JS methods.
         * NB: These are the view defined in the tzip4 standard, not the views introduced by the Hangzhou protocol.
         */
        this.views = {};
        /**
         * @description Contains on-chain views that are defined by the target Tezos Smart Contract, and offers the user to simulate the views execution as if they were native TS/JS methods.
         * NB: the expected format for the parameter when calling a smart contract view is the object format (same format as for the storage) and not the flattened representation.
         *
         */
        this.contractViews = {};
        this.contractMethodFactory = new contract_method_factory_1.ContractMethodFactory(provider, address);
        this.schema = michelson_encoder_1.Schema.fromRPCResponse({ script: this.script });
        this.parameterSchema = michelson_encoder_1.ParameterSchema.fromRPCResponse({ script: this.script });
        this.viewSchema = michelson_encoder_1.ViewSchema.fromRPCResponse({ script: this.script });
        if (this.viewSchema.length !== 0) {
            this._initializeOnChainViews(this, rpc, this.viewSchema);
        }
        this._initializeMethods(this, provider, this.entrypoints.entrypoints, this.chainId);
    }
    _initializeMethods(currentContract, provider, entrypoints, chainId) {
        const parameterSchema = this.parameterSchema;
        const keys = Object.keys(entrypoints);
        if (parameterSchema.isMultipleEntryPoint) {
            keys.forEach((smartContractMethodName) => {
                const smartContractMethodSchema = new michelson_encoder_1.ParameterSchema(entrypoints[smartContractMethodName]);
                this.methods[smartContractMethodName] = function (...args) {
                    return currentContract.contractMethodFactory.createContractMethodFlatParams(smartContractMethodSchema, smartContractMethodName, args);
                };
                this.methodsObject[smartContractMethodName] = function (args) {
                    return currentContract.contractMethodFactory.createContractMethodObjectParam(smartContractMethodSchema, smartContractMethodName, args);
                };
                if (isContractProvider(provider)) {
                    if (isView(entrypoints[smartContractMethodName])) {
                        const view = function (...args) {
                            const entrypointParamWithoutCallback = entrypoints[smartContractMethodName]
                                .args[0];
                            const smartContractMethodSchemaWithoutCallback = new michelson_encoder_1.ParameterSchema(entrypointParamWithoutCallback);
                            const parametersCallback = entrypoints[smartContractMethodName].args[1]
                                .args[0];
                            const smartContractMethodCallbackSchema = new michelson_encoder_1.ParameterSchema(parametersCallback);
                            validateArgs(args, smartContractMethodSchemaWithoutCallback, smartContractMethodName);
                            return new ContractView(currentContract, provider, smartContractMethodName, chainId, smartContractMethodCallbackSchema, smartContractMethodSchemaWithoutCallback, args);
                        };
                        this.views[smartContractMethodName] = view;
                    }
                }
            });
            // Deal with methods with no annotations which were not discovered by the RPC endpoint
            // Methods with no annotations are discovered using parameter schema
            const anonymousMethods = Object.keys(parameterSchema.ExtractSchema()).filter((key) => Object.keys(entrypoints).indexOf(key) === -1);
            anonymousMethods.forEach((smartContractMethodName) => {
                this.methods[smartContractMethodName] = function (...args) {
                    return currentContract.contractMethodFactory.createContractMethodFlatParams(parameterSchema, smartContractMethodName, args, false, true);
                };
                this.methodsObject[smartContractMethodName] = function (args) {
                    return currentContract.contractMethodFactory.createContractMethodObjectParam(parameterSchema, smartContractMethodName, args, false, true);
                };
            });
        }
        else {
            const smartContractMethodSchema = this.parameterSchema;
            this.methods[exports.DEFAULT_SMART_CONTRACT_METHOD_NAME] = function (...args) {
                return currentContract.contractMethodFactory.createContractMethodFlatParams(smartContractMethodSchema, exports.DEFAULT_SMART_CONTRACT_METHOD_NAME, args, false);
            };
            this.methodsObject[exports.DEFAULT_SMART_CONTRACT_METHOD_NAME] = function (args) {
                return currentContract.contractMethodFactory.createContractMethodObjectParam(smartContractMethodSchema, exports.DEFAULT_SMART_CONTRACT_METHOD_NAME, args, false);
            };
        }
    }
    _initializeOnChainViews(currentContract, rpc, allContractViews) {
        const storageType = this.schema.val;
        const storageValue = this.script.storage;
        allContractViews.forEach((viewSchema) => {
            this.contractViews[viewSchema.viewName] = function (args) {
                return currentContract.contractMethodFactory.createContractViewObjectParam(rpc, viewSchema, storageType, storageValue, args);
            };
        });
    }
    /**
     * @description Return a friendly representation of the smart contract storage
     */
    storage() {
        return this.storageProvider.getStorage(this.address, this.schema);
    }
    /**
     *
     * @description Return a friendly representation of the smart contract big map value
     *
     * @param key BigMap key to fetch
     *
     * @deprecated getBigMapKey has been deprecated in favor of getBigMapKeyByID
     *
     * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get
     */
    bigMap(key) {
        return this.storageProvider.getBigMapKey(this.address, key, this.schema);
    }
}
exports.ContractAbstraction = ContractAbstraction;
//# sourceMappingURL=contract.js.map