"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Context = exports.defaultConfigStreamer = exports.defaultConfigConfirmation = void 0;
const rpc_1 = require("@taquito/rpc");
const rpc_forger_1 = require("./forger/rpc-forger");
const rpc_injector_1 = require("./injector/rpc-injector");
const noop_1 = require("./signer/noop");
const operation_factory_1 = require("./wallet/operation-factory");
const rpc_tz_provider_1 = require("./tz/rpc-tz-provider");
const rpc_estimate_provider_1 = require("./contract/rpc-estimate-provider");
const rpc_contract_provider_1 = require("./contract/rpc-contract-provider");
const rpc_batch_provider_1 = require("./batch/rpc-batch-provider");
const wallet_1 = require("./wallet");
const michel_codec_parser_1 = require("./parser/michel-codec-parser");
const rpc_packer_1 = require("./packer/rpc-packer");
const bignumber_js_1 = require("bignumber.js");
const operators_1 = require("rxjs/operators");
const rxjs_1 = require("rxjs");
const noop_global_constants_provider_1 = require("./global-constants/noop-global-constants-provider");
exports.defaultConfigConfirmation = {
    defaultConfirmationCount: 1,
    confirmationPollingTimeoutSecond: 180,
};
exports.defaultConfigStreamer = {
    streamerPollingIntervalMilliseconds: 20000,
    shouldObservableSubscriptionRetry: false,
    observableSubscriptionRetryFunction: operators_1.retry(),
};
/**
 * @description Encapsulate common service used throughout different part of the library
 */
class Context {
    constructor(_rpc, _signer = new noop_1.NoopSigner(), _proto, _config = new rxjs_1.BehaviorSubject(Object.assign(Object.assign({}, exports.defaultConfigStreamer), exports.defaultConfigConfirmation)), forger, injector, packer, wallet, parser, globalConstantsProvider) {
        this._rpc = _rpc;
        this._signer = _signer;
        this._proto = _proto;
        this._config = _config;
        this.providerDecorator = [];
        this.tz = new rpc_tz_provider_1.RpcTzProvider(this);
        this.estimate = new rpc_estimate_provider_1.RPCEstimateProvider(this);
        this.contract = new rpc_contract_provider_1.RpcContractProvider(this, this.estimate);
        this.batch = new rpc_batch_provider_1.RPCBatchProvider(this, this.estimate);
        this.wallet = new wallet_1.Wallet(this);
        /**
         * @description Applies the decorators on a cloned instance of the context and returned this cloned instance.
         * The decorators are functions that inject logic into the context.
         * They are provided by the extensions set on the TezosToolkit by calling the registerProviderDecorator method.
         */
        this.withExtensions = () => {
            let clonedContext = this.clone();
            this.providerDecorator.forEach((decorator) => {
                clonedContext = decorator(clonedContext);
            });
            return clonedContext;
        };
        if (typeof this._rpc === 'string') {
            this._rpcClient = new rpc_1.RpcClient(this._rpc);
        }
        else {
            this._rpcClient = this._rpc;
        }
        this._forger = forger ? forger : new rpc_forger_1.RpcForger(this);
        this._injector = injector ? injector : new rpc_injector_1.RpcInjector(this);
        this.operationFactory = new operation_factory_1.OperationFactory(this);
        this._walletProvider = wallet ? wallet : new wallet_1.LegacyWalletProvider(this);
        this._parser = parser ? parser : new michel_codec_parser_1.MichelCodecParser(this);
        this._packer = packer ? packer : new rpc_packer_1.RpcPacker(this);
        this._globalConstantsProvider = globalConstantsProvider
            ? globalConstantsProvider
            : new noop_global_constants_provider_1.NoopGlobalConstantsProvider();
    }
    get config() {
        return this._config.getValue();
    }
    set config(value) {
        this._config.next(Object.assign({}, value));
    }
    setPartialConfig(value) {
        this._config.next(Object.assign(Object.assign({}, this._config.getValue()), value));
    }
    get rpc() {
        return this._rpcClient;
    }
    set rpc(value) {
        this._rpcClient = value;
    }
    get injector() {
        return this._injector;
    }
    set injector(value) {
        this._injector = value;
    }
    get forger() {
        return this._forger;
    }
    set forger(value) {
        this._forger = value;
    }
    get signer() {
        return this._signer;
    }
    set signer(value) {
        this._signer = value;
    }
    get walletProvider() {
        return this._walletProvider;
    }
    set walletProvider(value) {
        this._walletProvider = value;
    }
    set proto(value) {
        this._proto = value;
    }
    get proto() {
        return this._proto;
    }
    get parser() {
        return this._parser;
    }
    set parser(value) {
        this._parser = value;
    }
    get packer() {
        return this._packer;
    }
    set packer(value) {
        this._packer = value;
    }
    get globalConstantsProvider() {
        return this._globalConstantsProvider;
    }
    set globalConstantsProvider(value) {
        this._globalConstantsProvider = value;
    }
    isAnyProtocolActive(protocol = []) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._proto) {
                return protocol.includes(this._proto);
            }
            else {
                const { next_protocol } = yield this.rpc.getBlockMetadata();
                return protocol.includes(next_protocol);
            }
        });
    }
    getConfirmationPollingInterval() {
        return __awaiter(this, void 0, void 0, function* () {
            // Granada will generally halve the time between blocks, from 60 seconds to 30 seconds (mainnet).
            // We reduce the default value in the same proportion, from 10 to 5.
            const defaultInterval = 5;
            try {
                const constants = yield this.rpc.getConstants();
                let blockTime = constants.time_between_blocks[0];
                if (constants.minimal_block_delay !== undefined) {
                    blockTime = constants.minimal_block_delay;
                }
                let confirmationPollingInterval = bignumber_js_1.default.sum(blockTime, 
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                new bignumber_js_1.default(constants.delay_per_missing_endorsement).multipliedBy(
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                Math.max(0, constants.initial_endorsers - constants.endorsers_per_block)));
                // Divide the polling interval by a constant 3
                // to improvise for polling time to work in prod,
                // testnet and sandbox enviornment.
                confirmationPollingInterval = confirmationPollingInterval.dividedBy(3);
                this.config.confirmationPollingIntervalSecond =
                    confirmationPollingInterval.toNumber() === 0 ? 0.1 : confirmationPollingInterval.toNumber();
                return this.config.confirmationPollingIntervalSecond;
            }
            catch (exception) {
                // Return default value if there is
                // an issue returning from constants
                // file.
                return defaultInterval;
            }
        });
    }
    /**
     * @description Create a copy of the current context. Useful when you have long running operation and you do not want a context change to affect the operation
     */
    clone() {
        return new Context(this.rpc, this.signer, this.proto, this._config, this.forger, this._injector, this.packer);
    }
    /**
     * @description Allows extensions set on the TezosToolkit to inject logic into the context
     */
    registerProviderDecorator(fx) {
        this.providerDecorator.push(fx);
    }
}
exports.Context = Context;
//# sourceMappingURL=context.js.map