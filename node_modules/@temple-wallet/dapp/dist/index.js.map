{"version":3,"file":"index.js","sources":["../src/types.ts","../src/client.ts","../src/taquito-wallet.ts"],"sourcesContent":["export type TempleDAppMessage = TempleDAppRequest | TempleDAppResponse;\n\nexport type TempleDAppRequest =\n  | TempleDAppGetCurrentPermissionRequest\n  | TempleDAppPermissionRequest\n  | TempleDAppOperationRequest\n  | TempleDAppSignRequest\n  | TempleDAppBroadcastRequest;\n\nexport type TempleDAppResponse =\n  | TempleDAppGetCurrentPermissionResponse\n  | TempleDAppPermissionResponse\n  | TempleDAppOperationResponse\n  | TempleDAppSignResponse\n  | TempleDAppBroadcastResponse;\n\nexport interface TempleDAppMessageBase {\n  type: TempleDAppMessageType;\n}\n\nexport enum TempleDAppMessageType {\n  GetCurrentPermissionRequest = \"GET_CURRENT_PERMISSION_REQUEST\",\n  GetCurrentPermissionResponse = \"GET_CURRENT_PERMISSION_RESPONSE\",\n  PermissionRequest = \"PERMISSION_REQUEST\",\n  PermissionResponse = \"PERMISSION_RESPONSE\",\n  OperationRequest = \"OPERATION_REQUEST\",\n  OperationResponse = \"OPERATION_RESPONSE\",\n  SignRequest = \"SIGN_REQUEST\",\n  SignResponse = \"SIGN_RESPONSE\",\n  BroadcastRequest = \"BROADCAST_REQUEST\",\n  BroadcastResponse = \"BROADCAST_RESPONSE\",\n}\n\n/**\n * Messages\n */\n\nexport interface TempleDAppGetCurrentPermissionRequest\n  extends TempleDAppMessageBase {\n  type: TempleDAppMessageType.GetCurrentPermissionRequest;\n}\n\nexport interface TempleDAppGetCurrentPermissionResponse\n  extends TempleDAppMessageBase {\n  type: TempleDAppMessageType.GetCurrentPermissionResponse;\n  permission: TempleDAppPermission;\n}\n\nexport interface TempleDAppPermissionRequest extends TempleDAppMessageBase {\n  type: TempleDAppMessageType.PermissionRequest;\n  network: TempleDAppNetwork;\n  appMeta: TempleDAppMetadata;\n  force?: boolean;\n}\n\nexport interface TempleDAppPermissionResponse extends TempleDAppMessageBase {\n  type: TempleDAppMessageType.PermissionResponse;\n  pkh: string;\n  publicKey: string;\n  rpc: string;\n}\n\nexport interface TempleDAppOperationRequest extends TempleDAppMessageBase {\n  type: TempleDAppMessageType.OperationRequest;\n  sourcePkh: string;\n  opParams: any[];\n}\n\nexport interface TempleDAppOperationResponse extends TempleDAppMessageBase {\n  type: TempleDAppMessageType.OperationResponse;\n  opHash: string;\n}\n\nexport interface TempleDAppSignRequest extends TempleDAppMessageBase {\n  type: TempleDAppMessageType.SignRequest;\n  sourcePkh: string;\n  payload: string;\n}\n\nexport interface TempleDAppSignResponse extends TempleDAppMessageBase {\n  type: TempleDAppMessageType.SignResponse;\n  signature: string;\n}\n\nexport interface TempleDAppBroadcastRequest extends TempleDAppMessageBase {\n  type: TempleDAppMessageType.BroadcastRequest;\n  signedOpBytes: string;\n}\n\nexport interface TempleDAppBroadcastResponse extends TempleDAppMessageBase {\n  type: TempleDAppMessageType.BroadcastResponse;\n  opHash: string;\n}\n\n/**\n * Errors\n */\nexport enum TempleDAppErrorType {\n  NotGranted = \"NOT_GRANTED\",\n  NotFound = \"NOT_FOUND\",\n  InvalidParams = \"INVALID_PARAMS\",\n  TezosOperation = \"TEZOS_OPERATION\",\n}\n\n/**\n * Misc\n */\n\nexport type TempleDAppPermission = {\n  rpc: string;\n  pkh: string;\n  publicKey: string;\n} | null;\n\nexport type TempleDAppNetwork =\n  | \"mainnet\"\n  | \"ithacanet\"\n  | \"hangzhounet\"\n  | \"idiazabalnet\"\n  | \"granadanet\"\n  | \"edo2net\"\n  | \"florencenet\"\n  | \"sandbox\"\n  | { name: string; rpc: string };\n\nexport interface TempleDAppMetadata {\n  name: string;\n}\n\nexport interface TemplePageMessage {\n  type: TemplePageMessageType;\n  payload: any;\n  reqId?: string | number;\n}\n\nexport enum TemplePageMessageType {\n  Request = \"TEMPLE_PAGE_REQUEST\",\n  Response = \"TEMPLE_PAGE_RESPONSE\",\n  ErrorResponse = \"TEMPLE_PAGE_ERROR_RESPONSE\",\n}\n","import { nanoid } from \"nanoid\";\nimport { TezosOperationError } from \"@taquito/taquito\";\nimport {\n  TemplePageMessageType,\n  TemplePageMessage,\n  TempleDAppMessageType,\n  TempleDAppRequest,\n  TempleDAppResponse,\n  TempleDAppErrorType,\n  TempleDAppNetwork,\n  TempleDAppMetadata,\n  TempleDAppPermission,\n} from \"./types\";\n\nexport function isAvailable() {\n  return new Promise<boolean>((resolve) => {\n    const handleMessage = (evt: MessageEvent) => {\n      if (\n        evt.source === window &&\n        evt.data?.type === TemplePageMessageType.Response &&\n        evt.data?.payload === \"PONG\"\n      ) {\n        done(true);\n      }\n    };\n\n    const done = (result: boolean) => {\n      resolve(result);\n      window.removeEventListener(\"message\", handleMessage);\n      clearTimeout(t);\n    };\n\n    send({\n      type: TemplePageMessageType.Request,\n      payload: \"PING\",\n    });\n    window.addEventListener(\"message\", handleMessage);\n    const t = setTimeout(() => done(false), 500);\n  });\n}\n\nexport function onAvailabilityChange(callback: (available: boolean) => void) {\n  let t: any;\n  let currentStatus = false;\n  const check = async (attempt = 0) => {\n    const initial = attempt < 5;\n    const available = await isAvailable();\n    if (currentStatus !== available) {\n      callback(available);\n      currentStatus = available;\n    }\n    t = setTimeout(\n      check,\n      available ? 10_000 : !initial ? 5_000 : 0,\n      initial ? attempt + 1 : attempt\n    );\n  };\n  check();\n  return () => clearTimeout(t);\n}\n\nexport function onPermissionChange(\n  callback: (permission: TempleDAppPermission) => void\n) {\n  let t: any;\n  let currentPerm: TempleDAppPermission = null;\n  const check = async () => {\n    try {\n      const perm = await getCurrentPermission();\n      if (!permissionsAreEqual(perm, currentPerm)) {\n        callback(perm);\n        currentPerm = perm;\n      }\n    } catch {}\n\n    t = setTimeout(check, 10_000);\n  };\n  check();\n  return () => clearTimeout(t);\n}\n\nexport async function getCurrentPermission() {\n  const res = await request({\n    type: TempleDAppMessageType.GetCurrentPermissionRequest,\n  });\n  assertResponse(\n    res.type === TempleDAppMessageType.GetCurrentPermissionResponse\n  );\n  return res.permission;\n}\n\nexport async function requestPermission(\n  network: TempleDAppNetwork,\n  appMeta: TempleDAppMetadata,\n  force: boolean\n) {\n  const res = await request({\n    type: TempleDAppMessageType.PermissionRequest,\n    network,\n    appMeta,\n    force,\n  });\n  assertResponse(res.type === TempleDAppMessageType.PermissionResponse);\n  return {\n    rpc: res.rpc,\n    pkh: res.pkh,\n    publicKey: res.publicKey,\n  };\n}\n\nexport async function requestOperation(sourcePkh: string, opParams: any) {\n  const res = await request({\n    type: TempleDAppMessageType.OperationRequest,\n    sourcePkh,\n    opParams,\n  });\n  assertResponse(res.type === TempleDAppMessageType.OperationResponse);\n  return res.opHash;\n}\n\nexport async function requestSign(sourcePkh: string, payload: string) {\n  const res = await request({\n    type: TempleDAppMessageType.SignRequest,\n    sourcePkh,\n    payload,\n  });\n  assertResponse(res.type === TempleDAppMessageType.SignResponse);\n  return res.signature;\n}\n\nexport async function requestBroadcast(signedOpBytes: string) {\n  const res = await request({\n    type: TempleDAppMessageType.BroadcastRequest,\n    signedOpBytes,\n  });\n  assertResponse(res.type === TempleDAppMessageType.BroadcastResponse);\n  return res.opHash;\n}\n\nfunction request(payload: TempleDAppRequest) {\n  return new Promise<TempleDAppResponse>((resolve, reject) => {\n    const reqId = nanoid();\n    const handleMessage = (evt: MessageEvent) => {\n      const res = evt.data as TemplePageMessage;\n      switch (true) {\n        case evt.source !== window || res?.reqId !== reqId:\n          return;\n\n        case res?.type === TemplePageMessageType.Response:\n          resolve(res.payload);\n          window.removeEventListener(\"message\", handleMessage);\n          break;\n\n        case res?.type === TemplePageMessageType.ErrorResponse:\n          reject(createError(res.payload));\n          window.removeEventListener(\"message\", handleMessage);\n          break;\n      }\n    };\n\n    send({\n      type: TemplePageMessageType.Request,\n      payload,\n      reqId,\n    });\n\n    window.addEventListener(\"message\", handleMessage);\n  });\n}\n\nfunction permissionsAreEqual(\n  aPerm: TempleDAppPermission,\n  bPerm: TempleDAppPermission\n) {\n  if (aPerm === null) return bPerm === null;\n  return aPerm.pkh === bPerm?.pkh && aPerm.rpc === bPerm?.rpc;\n}\n\nfunction createError(payload: any) {\n  switch (true) {\n    case payload === TempleDAppErrorType.NotGranted:\n      return new NotGrantedTempleWalletError();\n\n    case payload === TempleDAppErrorType.NotFound:\n      return new NotFoundTempleWalletError();\n\n    case payload === TempleDAppErrorType.InvalidParams:\n      return new InvalidParamsTempleWalletError();\n\n    case Array.isArray(payload) &&\n      payload[0] === TempleDAppErrorType.TezosOperation &&\n      Array.isArray(payload[1]) &&\n      payload[1].length > 0:\n      return new TezosOperationError(payload[1]);\n\n    case typeof payload === \"string\" && payload.startsWith(\"__tezos__\"):\n      return new Error(payload.replace(\"__tezos__\", \"\"));\n\n    default:\n      return new TempleWalletError();\n  }\n}\n\nfunction assertResponse(condition: any): asserts condition {\n  if (!condition) {\n    throw new Error(\"Invalid response recieved\");\n  }\n}\n\nfunction send(msg: TemplePageMessage) {\n  window.postMessage(msg, \"*\");\n}\n\nexport class TempleWalletError implements Error {\n  name = \"TempleWalletError\";\n  message = \"An unknown error occured. Please try again or report it\";\n}\n\nexport class NotGrantedTempleWalletError extends TempleWalletError {\n  name = \"NotGrantedTempleWalletError\";\n  message = \"Permission Not Granted\";\n}\n\nexport class NotFoundTempleWalletError extends TempleWalletError {\n  name = \"NotFoundTempleWalletError\";\n  message = \"Account Not Found. Try connect again\";\n}\n\nexport class InvalidParamsTempleWalletError extends TempleWalletError {\n  name = \"InvalidParamsTempleWalletError\";\n  message = \"Some of the parameters you provided are invalid\";\n}\n","import {\n  TezosToolkit,\n  WalletProvider,\n  createOriginationOperation,\n  createSetDelegateOperation,\n  createTransferOperation,\n  WalletDelegateParams,\n  WalletTransferParams,\n  WalletOriginateParams,\n} from \"@taquito/taquito\";\n\nimport {\n  isAvailable,\n  onAvailabilityChange,\n  getCurrentPermission,\n  onPermissionChange,\n  requestPermission,\n  requestOperation,\n  requestSign,\n  requestBroadcast,\n  TempleWalletError,\n} from \"./client\";\n\nimport { TempleDAppNetwork, TempleDAppPermission } from \"./types\";\n\nexport class TempleWallet implements WalletProvider {\n  static isAvailable = isAvailable;\n  static onAvailabilityChange = onAvailabilityChange;\n  static getCurrentPermission = getCurrentPermission;\n  static onPermissionChange = onPermissionChange;\n\n  permission: TempleDAppPermission = null;\n\n  constructor(\n    private appName: string,\n    existingPermission?: TempleDAppPermission\n  ) {\n    if (existingPermission) {\n      this.permission = existingPermission;\n    }\n  }\n\n  get connected() {\n    return Boolean(this.permission);\n  }\n\n  toTezos() {\n    assertConnected(this.permission);\n    const tezos = new TezosToolkit(this.permission.rpc);\n    tezos.setProvider({ wallet: this });\n    return tezos;\n  }\n\n  async connect(network: TempleDAppNetwork, opts = { forcePermission: false }) {\n    const perm = await requestPermission(\n      network,\n      { name: this.appName },\n      opts.forcePermission\n    );\n    this.permission = perm;\n  }\n\n  reconnect(network: TempleDAppNetwork) {\n    return this.connect(network, { forcePermission: true });\n  }\n\n  async getPKH() {\n    assertConnected(this.permission);\n    return this.permission.pkh;\n  }\n\n  async mapTransferParamsToWalletParams(\n    params: () => Promise<WalletTransferParams>\n  ) {\n    const walletParams = await params();\n    return this.removeDefaultParams(\n      walletParams,\n      await createTransferOperation(this.formatParameters(walletParams))\n    );\n  }\n\n  async mapOriginateParamsToWalletParams(\n    params: () => Promise<WalletOriginateParams>\n  ) {\n    const walletParams = await params();\n    return this.removeDefaultParams(\n      walletParams,\n      await createOriginationOperation(this.formatParameters(walletParams))\n    );\n  }\n\n  async mapDelegateParamsToWalletParams(\n    params: () => Promise<WalletDelegateParams>\n  ) {\n    const walletParams = await params();\n    return this.removeDefaultParams(\n      walletParams,\n      await createSetDelegateOperation(this.formatParameters(walletParams))\n    );\n  }\n\n  async sendOperations(opParams: any[]) {\n    assertConnected(this.permission);\n    return requestOperation(this.permission.pkh, opParams.map(formatOpParams));\n  }\n\n  async sign(payload: string) {\n    assertConnected(this.permission);\n    return requestSign(this.permission.pkh, payload);\n  }\n\n  async broadcast(signedOpBytes: string) {\n    assertConnected(this.permission);\n    return requestBroadcast(signedOpBytes);\n  }\n\n  private formatParameters(params: any) {\n    if (params.fee) {\n      params.fee = params.fee.toString();\n    }\n    if (params.storageLimit) {\n      params.storageLimit = params.storageLimit.toString();\n    }\n    if (params.gasLimit) {\n      params.gasLimit = params.gasLimit.toString();\n    }\n    return params;\n  }\n\n  private removeDefaultParams(\n    params: WalletTransferParams | WalletOriginateParams | WalletDelegateParams,\n    operatedParams: any\n  ) {\n    // If fee, storageLimit or gasLimit is undefined by user\n    // in case of beacon wallet, dont override it by\n    // defaults.\n    if (!params.fee) {\n      delete operatedParams.fee;\n    }\n    if (!params.storageLimit) {\n      delete operatedParams.storage_limit;\n    }\n    if (!params.gasLimit) {\n      delete operatedParams.gas_limit;\n    }\n    return operatedParams;\n  }\n}\n\nexport class NotConnectedTempleWalletError extends TempleWalletError {\n  name = \"TempleWalletNotConnected\";\n  message =\n    \"You need to connect TempleWallet by calling templeWallet.connect() first\";\n}\n\nfunction assertConnected(perm: TempleDAppPermission): asserts perm {\n  if (!perm) {\n    throw new NotConnectedTempleWalletError();\n  }\n}\n\nfunction formatOpParams(op: any) {\n  const { fee, gas_limit, storage_limit, ...rest } = op;\n\n  switch (op.kind) {\n    case \"origination\":\n      return {\n        ...rest,\n        mutez: true, // The balance was already converted from Tez (ꜩ) to Mutez (uꜩ)\n        fee,\n        gasLimit: gas_limit,\n        storageLimit: storage_limit,\n      };\n\n    case \"transaction\":\n      const { destination, amount, parameters, ...txRest } = rest;\n      return {\n        ...txRest,\n        to: destination,\n        amount: +amount,\n        mutez: true,\n        parameter: parameters,\n        fee,\n        gasLimit: gas_limit,\n        storageLimit: storage_limit,\n      };\n\n    default:\n      return {\n        ...rest,\n        fee,\n        gasLimit: gas_limit,\n        storageLimit: storage_limit,\n      };\n  }\n}\n"],"names":["TempleDAppMessageType","TempleDAppErrorType","TemplePageMessageType","requestBroadcast","signedOpBytes","request","type","BroadcastRequest","res","assertResponse","BroadcastResponse","opHash","requestSign","sourcePkh","payload","SignRequest","SignResponse","signature","requestOperation","opParams","OperationRequest","OperationResponse","requestPermission","network","appMeta","force","PermissionRequest","PermissionResponse","rpc","pkh","publicKey","getCurrentPermission","GetCurrentPermissionRequest","GetCurrentPermissionResponse","permission","isAvailable","Promise","resolve","handleMessage","evt","source","window","data","Response","done","result","removeEventListener","clearTimeout","t","send","Request","addEventListener","setTimeout","onAvailabilityChange","callback","currentStatus","check","attempt","initial","available","onPermissionChange","currentPerm","perm","aPerm","bPerm","reject","reqId","nanoid","ErrorResponse","NotGranted","NotGrantedTempleWalletError","NotFound","NotFoundTempleWalletError","InvalidParams","InvalidParamsTempleWalletError","Array","isArray","TezosOperation","length","TezosOperationError","startsWith","Error","replace","TempleWalletError","createError","condition","msg","postMessage","name","message","TempleWallet","appName","existingPermission","this","toTezos","assertConnected","tezos","TezosToolkit","setProvider","wallet","connect","opts","forcePermission","_this2","reconnect","getPKH","mapTransferParamsToWalletParams","params","walletParams","_this6","removeDefaultParams","createTransferOperation","formatParameters","mapOriginateParamsToWalletParams","_this8","createOriginationOperation","mapDelegateParamsToWalletParams","_this10","createSetDelegateOperation","sendOperations","map","formatOpParams","sign","broadcast","fee","toString","storageLimit","gasLimit","operatedParams","storage_limit","gas_limit","Boolean","NotConnectedTempleWalletError","op","rest","kind","mutez","destination","amount","parameters","to","parameter"],"mappings":"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"}