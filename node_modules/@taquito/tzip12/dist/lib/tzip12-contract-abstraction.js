"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tzip12ContractAbstraction = void 0;
const michelson_encoder_1 = require("@taquito/michelson-encoder");
const tzip16_1 = require("@taquito/tzip16");
const tzip12_errors_1 = require("./tzip12-errors");
const tokenMetadataBigMapType = {
    prim: 'big_map',
    args: [
        { prim: 'nat' },
        {
            prim: 'pair',
            args: [
                { prim: 'nat', annots: ['%token_id'] },
                { prim: 'map', args: [{ prim: 'string' }, { prim: 'bytes' }], annots: ['%token_info'] },
            ],
        },
    ],
    annots: ['%token_metadata'],
};
class Tzip12ContractAbstraction {
    constructor(contractAbstraction, context) {
        this.contractAbstraction = contractAbstraction;
        this.context = context;
        this._tzip16ContractAbstraction = new tzip16_1.Tzip16ContractAbstraction(this.contractAbstraction, this.context);
    }
    /**
     * @description Fetches the contract metadata (according to the Tzip-016 standard)
     * @returns An object containing the metadata, the uri, an optional integrity check result and an optional sha256 hash
     * or `Undefined` if the contract has no metadata (non-compliant with Tzip-016)
     */
    getContractMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const contractMetadata = yield this._tzip16ContractAbstraction.getMetadata();
                return contractMetadata.metadata;
            }
            catch (err) {
                // The contract is not compliant with Tzip-016. There is no contract metadata.
            }
        });
    }
    /**
     * @description The Tzip-016 "interfaces" field MUST be present in the contract metadata. It should contain "TZIP-012[version-info]"
     * @returns True if "interfaces" field is present and contains "TZIP-012", false otherwise
     */
    isTzip12Compliant() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let isCompliant = false;
            const metadata = yield this.getContractMetadata();
            if (metadata) {
                const tzip12Interface = (_a = metadata.interfaces) === null || _a === void 0 ? void 0 : _a.filter((x) => {
                    return x.substring(0, 8) === 'TZIP-012';
                });
                isCompliant = tzip12Interface && tzip12Interface.length !== 0 ? true : false;
            }
            return isCompliant;
        });
    }
    /**
     * @description Fetches the token metadata for a specified token ID.
     * The function first tries to find a `token_metadata` view in the contract metadata and to execute it with the token ID.
     * If there is no view, the function tries to find a `token_metadata` bigmap in the top-level pairs of the storage.
     * @param tokenId The ID of the token for which we want to retrieve token metadata
     * @returns An object of type `TokenMetadata`
     */
    getTokenMetadata(tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenMetadata = yield this.retrieveTokenMetadataFromView(tokenId);
            return !tokenMetadata ? this.retrieveTokenMetadataFromBigMap(tokenId) : tokenMetadata;
        });
    }
    retrieveTokenMetadataFromView(tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (yield this.getContractMetadata()) {
                const views = yield this._tzip16ContractAbstraction.metadataViews();
                if (views && this.hasTokenMetadataView(views)) {
                    return this.executeTokenMetadataView(views['token_metadata'](), tokenId);
                }
            }
        });
    }
    hasTokenMetadataView(views) {
        for (const view of Object.keys(views)) {
            if (view === 'token_metadata') {
                return true;
            }
        }
        return false;
    }
    executeTokenMetadataView(tokenMetadataView, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenMetadata = yield tokenMetadataView.executeView(tokenId);
            const tokenMap = Object.values(tokenMetadata)[1];
            if (!michelson_encoder_1.MichelsonMap.isMichelsonMap(tokenMap)) {
                throw new tzip12_errors_1.TokenMetadataNotFound(this.contractAbstraction.address);
            }
            const metadataFromUri = yield this.fetchTokenMetadataFromUri(tokenMap);
            return this.formatMetadataToken(tokenId, tokenMap, metadataFromUri);
        });
    }
    fetchTokenMetadataFromUri(tokenMetadata) {
        return __awaiter(this, void 0, void 0, function* () {
            const uri = tokenMetadata.get('');
            if (uri) {
                try {
                    const metadataFromUri = yield this.context.metadataProvider.provideMetadata(this.contractAbstraction, tzip16_1.bytes2Char(uri), this.context);
                    return metadataFromUri.metadata;
                }
                catch (e) {
                    if (e.name === 'InvalidUri') {
                        console.warn(`The URI ${tzip16_1.bytes2Char(uri)} is present in the token metadata, but is invalid.`);
                    }
                    else {
                        throw e;
                    }
                }
            }
        });
    }
    formatMetadataToken(tokenId, metadataTokenMap, metadataFromUri) {
        const tokenMetadataDecoded = {
            token_id: tokenId,
        };
        for (const keyTokenMetadata of metadataTokenMap.keys()) {
            if (keyTokenMetadata === 'decimals') {
                Object.assign(tokenMetadataDecoded, {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    [keyTokenMetadata]: Number(tzip16_1.bytes2Char(metadataTokenMap.get(keyTokenMetadata))),
                });
            }
            else if (!(keyTokenMetadata === '')) {
                Object.assign(tokenMetadataDecoded, {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    [keyTokenMetadata]: tzip16_1.bytes2Char(metadataTokenMap.get(keyTokenMetadata)),
                });
            }
        }
        // if an URI is present, add the fetched properties to the object
        // if a property is in the URI and the map, prevalence is accorded to value from the URI
        if (metadataFromUri) {
            for (const property in metadataFromUri) {
                Object.assign(tokenMetadataDecoded, { [property]: metadataFromUri[property] });
            }
        }
        if (!('decimals' in tokenMetadataDecoded)) {
            throw new tzip12_errors_1.InvalidTokenMetadata();
        }
        return tokenMetadataDecoded;
    }
    retrieveTokenMetadataFromBigMap(tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            const bigmapTokenMetadataId = this.findTokenMetadataBigMap();
            let pairNatMap;
            try {
                pairNatMap = yield this.context.contract.getBigMapKeyByID(bigmapTokenMetadataId['int'].toString(), tokenId.toString(), new michelson_encoder_1.Schema(tokenMetadataBigMapType));
            }
            catch (err) {
                throw new tzip12_errors_1.TokenIdNotFound(tokenId);
            }
            const michelsonMap = pairNatMap['token_info'];
            if (!michelson_encoder_1.MichelsonMap.isMichelsonMap(michelsonMap)) {
                throw new tzip12_errors_1.TokenIdNotFound(tokenId);
            }
            const metadataFromUri = yield this.fetchTokenMetadataFromUri(michelsonMap);
            return this.formatMetadataToken(tokenId, michelsonMap, metadataFromUri);
        });
    }
    findTokenMetadataBigMap() {
        const tokenMetadataBigMapId = this.contractAbstraction.schema.FindFirstInTopLevelPair(this.contractAbstraction.script.storage, tokenMetadataBigMapType);
        if (!tokenMetadataBigMapId) {
            throw new tzip12_errors_1.TokenMetadataNotFound(this.contractAbstraction.address);
        }
        return tokenMetadataBigMapId;
    }
}
exports.Tzip12ContractAbstraction = Tzip12ContractAbstraction;
//# sourceMappingURL=tzip12-contract-abstraction.js.map