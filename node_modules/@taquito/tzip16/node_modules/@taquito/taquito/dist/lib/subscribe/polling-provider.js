"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PollingSubscribeProvider = void 0;
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const filters_1 = require("./filters");
const observable_subscription_1 = require("./observable-subscription");
const getLastBlock = (context) => {
    return rxjs_1.from(context.rpc.getBlock()).pipe(operators_1.first());
};
const applyFilter = (filter) => operators_1.concatMap(block => {
    return new rxjs_1.Observable(sub => {
        for (const ops of block.operations) {
            for (const op of ops) {
                for (const content of op.contents) {
                    if (filters_1.evaluateFilter(Object.assign({ hash: op.hash }, content), filter)) {
                        sub.next(Object.assign({ hash: op.hash }, content));
                    }
                }
            }
        }
        sub.complete();
    });
});
class PollingSubscribeProvider {
    constructor(context) {
        this.context = context;
        // Map the changing polling interval to a timer, which will automatically terminate the previous timer when the next one starts.
        this.timer$ = this.context._config.pipe(operators_1.switchMap((val) => rxjs_1.timer(0, val.streamerPollingIntervalMilliseconds)));
        this.newBlock$ = this.timer$.pipe(operators_1.map(() => this.context), operators_1.switchMap(getLastBlock), operators_1.distinctUntilKeyChanged('hash'), operators_1.publish(), operators_1.refCount());
    }
    subscribe(_filter) {
        return new observable_subscription_1.ObservableSubscription(this.newBlock$.pipe(operators_1.pluck('hash')), this.context.config.shouldObservableSubscriptionRetry, this.context.config.observableSubscriptionRetryFunction);
    }
    subscribeOperation(filter) {
        return new observable_subscription_1.ObservableSubscription(this.newBlock$.pipe(applyFilter(filter)), this.context.config.shouldObservableSubscriptionRetry, this.context.config.observableSubscriptionRetryFunction);
    }
}
exports.PollingSubscribeProvider = PollingSubscribeProvider;
//# sourceMappingURL=polling-provider.js.map