import { HttpBackend } from '@taquito/http-utils';
import { Schema, ParameterSchema } from '@taquito/michelson-encoder';
import { bytes2Char } from '@taquito/utils';
export { bytes2Char, char2Bytes } from '@taquito/utils';
import { validateAndExtractFailwith, ViewSimulationError, BigMapAbstraction } from '@taquito/taquito';
import BigNumber from 'bignumber.js';
import CryptoJS from 'crypto-js';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

class HttpHandler {
    constructor() {
        this.httpBackend = new HttpBackend();
    }
    getMetadata(_contractAbstraction, { protocol, location }, _context) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.httpBackend.createRequest({
                url: `${protocol}:${decodeURIComponent(location)}`,
                method: 'GET',
                mimeType: "text; charset=utf-8",
                json: false
            });
        });
    }
}

class BigMapMetadataNotFound extends Error {
    constructor() {
        super('Non-compliance with the TZIP-016 standard. No big map named metadata was found in the contract storage.');
        this.name = 'BigMapMetadataNotFound';
    }
}
class MetadataNotFound extends Error {
    constructor(info) {
        super(`No metadata was found in the contract storage. ${info}`);
        this.info = info;
        this.name = 'MetadataNotFound';
    }
}
class UriNotFound extends Error {
    constructor() {
        super('Non-compliance with the TZIP-016 standard. No URI found in the contract storage.');
        this.name = 'UriNotFound';
    }
}
class InvalidUri extends Error {
    constructor(uri) {
        super(`Non-compliance with the TZIP-016 standard. The URI is invalid: ${uri}.`);
        this.uri = uri;
        this.name = 'InvalidUri';
    }
}
class InvalidMetadata extends Error {
    constructor(invalidMetadata) {
        super(`The metadata found at the pointed ressource are not compliant with tzip16 standard: ${invalidMetadata}.`);
        this.invalidMetadata = invalidMetadata;
        this.name = 'InvalidMetadata';
    }
}
class ProtocolNotSupported extends Error {
    constructor(protocol) {
        super(`The protocol found in the URI is not supported: ${protocol}.`);
        this.protocol = protocol;
        this.name = 'ProtocolNotSupported';
    }
}
class InvalidMetadataType extends Error {
    constructor() {
        super('The contract does not comply with the tzip16 standard. The type of metadata should be bytes.');
        this.name = 'InvalidMetadataType';
    }
}
class UnconfiguredMetadataProviderError extends Error {
    constructor() {
        super('No metadata provider has been configured. The default one can be configured by calling addExtension(new Tzip16Module()) on your TezosToolkit instance.');
        this.name = 'UnconfiguredMetadataProviderError';
    }
}
class ForbiddenInstructionInViewCode extends Error {
    constructor(instruction) {
        super(`Error found in the code of the view. It contains a forbidden instruction: ${instruction}.`);
        this.instruction = instruction;
        this.name = 'ForbiddenInstructionInViewCode';
    }
}
class NoParameterExpectedError extends Error {
    constructor(viewName, args) {
        super(`${viewName} Received ${args.length} arguments while expecting no parameter or 'Unit'`);
        this.viewName = viewName;
        this.args = args;
        this.name = 'NoParameterExpectedError';
    }
}
class InvalidViewParameterError extends Error {
    constructor(viewName, sigs, args) {
        super(`${viewName} Received ${args.length} arguments while expecting one of the following signatures (${JSON.stringify(sigs)})`);
        this.viewName = viewName;
        this.sigs = sigs;
        this.args = args;
        this.name = 'InvalidViewParameterError';
    }
}

const typeOfValueToFind = {
    prim: 'big_map',
    args: [{ prim: 'string' }, { prim: 'bytes' }],
    annots: ['%metadata'],
};
class TezosStorageHandler {
    constructor() {
        this.TEZOS_STORAGE_REGEX = /^(?:\/\/(KT1\w{33})(?:\.(.+))?\/)?([\w|%]+)$/;
    }
    getMetadata(contractAbstraction, { location }, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const parsedTezosStorageUri = this.parseTezosStorageUri(location);
            if (!parsedTezosStorageUri) {
                throw new InvalidUri(`tezos-storage:${location}`);
            }
            const storage = yield context.rpc.getNormalizedScript(parsedTezosStorageUri.contractAddress || contractAbstraction.address);
            const bigMapId = Schema.fromRPCResponse({ script: storage }).FindFirstInTopLevelPair(storage.storage, typeOfValueToFind);
            if (!bigMapId) {
                throw new BigMapMetadataNotFound();
            }
            const bytes = yield context.contract.getBigMapKeyByID(bigMapId['int'].toString(), parsedTezosStorageUri.path, new Schema(typeOfValueToFind));
            if (!bytes) {
                throw new MetadataNotFound(`No '${parsedTezosStorageUri.path}' key found in the big map %metadata of the contract ${parsedTezosStorageUri.contractAddress || contractAbstraction.address}`);
            }
            if (!/^[0-9a-fA-F]*$/.test(bytes)) {
                throw new InvalidMetadataType();
            }
            return bytes2Char(bytes);
        });
    }
    /**
     * @description Extract the smart contract address, the network and the path pointing to the metadata from the uri
     * @returns an object which contains the properties allowing to find where the metadata are located or it returns undefined if the uri is not valid
     * @param tezosStorageURI URI (without the tezos-storage prefix)
     */
    parseTezosStorageUri(tezosStorageURI) {
        const extractor = this.TEZOS_STORAGE_REGEX.exec(tezosStorageURI);
        if (!extractor)
            return;
        return {
            contractAddress: extractor[1],
            network: extractor[2],
            path: decodeURIComponent(extractor[3]),
        };
    }
}

class IpfsHttpHandler {
    constructor(ipfsGatheway) {
        this.httpBackend = new HttpBackend();
        this._ipfsGateway = ipfsGatheway ? ipfsGatheway : 'ipfs.io';
    }
    getMetadata(_contractAbstraction, { location }, _context) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.httpBackend.createRequest({
                url: `https://${this._ipfsGateway}/ipfs/${location.substring(2)}/`,
                method: 'GET',
                headers: { 'Content-Type': 'text/plain' },
                mimeType: "text; charset=utf-8",
                json: false
            });
        });
    }
}

var ViewImplementationType;
(function (ViewImplementationType) {
    ViewImplementationType["MICHELSON_STORAGE"] = "michelsonStorageView";
    ViewImplementationType["REST_API_QUERY"] = "restApiQuery";
})(ViewImplementationType || (ViewImplementationType = {}));

class MichelsonStorageView {
    constructor(viewName, contract, rpc, returnType, code, viewParameterType) {
        this.viewName = viewName;
        this.contract = contract;
        this.rpc = rpc;
        this.returnType = returnType;
        this.code = code;
        this.viewParameterType = viewParameterType;
        this.validateArgs = (args, schema, viewName) => {
            const sigs = schema.ExtractSignatures();
            if (!sigs.find((x) => x.length === args.length)) {
                throw new InvalidViewParameterError(viewName, sigs, args);
            }
        };
    }
    /**
     * @description According to the tzip-16 standard, the following instructions must not be used in the code of the view:
     * 'AMOUNT', 'CREATE_CONTRACT', 'SENDER', 'SET_DELEGATE', 'SOURCE', and 'TRANSFER_TOKENS'
     * The method throw an error if an illegal instruction is found
     */
    findForbiddenInstructionInViewCode(code) {
        const illegalInstructions = [
            'AMOUNT',
            'CREATE_CONTRACT',
            'SENDER',
            'SET_DELEGATE',
            'SOURCE',
            'TRANSFER_TOKENS',
        ];
        for (const forbiddenInstruction of illegalInstructions) {
            for (const instruction of code) {
                if (instruction.prim === forbiddenInstruction) {
                    throw new ForbiddenInstructionInViewCode(forbiddenInstruction);
                }
                if (instruction.args && instruction.args.length !== 0) {
                    this.findForbiddenInstructionInViewCode(instruction.args);
                }
            }
        }
    }
    /**
     * @description According to the tzip-16 standard, in the first version of the specification, the instruction SELF should only be used before ADDRESS
     * The method throws an error is the instruction SELF is present, but not followed by ADDRESS
     */
    illegalUseOfSelfInstruction(code) {
        for (const instruction of code) {
            if (instruction.prim === 'SELF') {
                const index = code.indexOf(instruction);
                const nextInstruction = code[index + 1] ? code[index + 1].prim : undefined;
                if (nextInstruction !== 'ADDRESS') {
                    throw new ForbiddenInstructionInViewCode('the instruction SELF should only be used before ADDRESS');
                }
            }
            if (instruction.args && instruction.args.length !== 0) {
                this.illegalUseOfSelfInstruction(instruction.args);
            }
        }
    }
    /**
     * @description Loops through the view's code and replace SELF, BALANCE, NOW, and CHAIN_ID with Michelson expressions that match the current context, if applicable.
     */
    adaptViewCodeToContext(code, contractBalance, blockTimeStamp, chainId) {
        const instructionsToReplace = {
            SELF: [
                { prim: 'PUSH', args: [{ prim: 'address' }, { string: this.contract.address }] },
                { prim: 'CONTRACT', args: [{ prim: 'unit' }] },
                { prim: 'IF_NONE', args: [[{ prim: 'UNIT' }, { prim: 'FAILWITH' }], []] },
            ],
            BALANCE: [{ prim: 'PUSH', args: [{ prim: 'mutez' }, { int: contractBalance }] }],
            NOW: [{ prim: 'PUSH', args: [{ prim: 'timestamp' }, { string: blockTimeStamp }] }],
            CHAIN_ID: [{ prim: 'PUSH', args: [{ prim: 'string' }, { string: chainId }] }],
        };
        code.forEach((x, i) => {
            for (const instruction in instructionsToReplace) {
                if (x.prim === instruction) {
                    code[i] = Object(instructionsToReplace)[instruction];
                }
                if (x.args && x.args.length !== 0) {
                    this.adaptViewCodeToContext(x.args, contractBalance, blockTimeStamp, chainId);
                }
            }
        });
        return code;
    }
    formatArgsAndParameter(argView) {
        let args = argView;
        let viewParameterType = this.viewParameterType;
        if (!viewParameterType) {
            viewParameterType = { args: [], prim: 'unit', annots: [] };
        }
        if (viewParameterType.prim === 'unit') {
            if (args.length === 0) {
                args = ['Unit'];
            }
            if (args.length !== 0 && args[0] !== 'Unit') {
                throw new NoParameterExpectedError(this.viewName, argView);
            }
        }
        const parameterViewSchema = new ParameterSchema(viewParameterType);
        this.validateArgs(args, parameterViewSchema, this.viewName);
        const arg = parameterViewSchema.Encode(...args);
        return { arg, viewParameterType };
    }
    executeView(...args) {
        return __awaiter(this, void 0, void 0, function* () {
            // validate view code against tzip-16 specifications
            this.findForbiddenInstructionInViewCode(this.code);
            this.illegalUseOfSelfInstruction(this.code);
            const { arg, viewParameterType } = this.formatArgsAndParameter(args);
            const storageType = this.contract.script.code.find((x) => x.prim === 'storage');
            const storageArgs = storageType.args[0];
            const storageValue = this.contract.script.storage;
            // currentContext
            const chainId = yield this.rpc.getChainId();
            const contractBalance = (yield this.rpc.getBalance(this.contract.address)).toString();
            const block = yield this.rpc.getBlock();
            const blockTimestamp = block.header.timestamp.toString();
            const code = this.adaptViewCodeToContext(this.code, contractBalance, blockTimestamp, chainId);
            if (!this.viewParameterType) {
                code.unshift({ prim: 'CDR' });
            }
            const viewScript = {
                script: [
                    { prim: 'parameter', args: [{ prim: 'pair', args: [viewParameterType, storageArgs] }] },
                    { prim: 'storage', args: [{ prim: 'option', args: [this.returnType] }] },
                    {
                        prim: 'code',
                        args: [
                            [
                                { prim: 'CAR' },
                                code,
                                { prim: 'SOME' },
                                { prim: 'NIL', args: [{ prim: 'operation' }] },
                                { prim: 'PAIR' },
                            ],
                        ],
                    },
                ],
                storage: { prim: 'None' },
                input: { prim: 'Pair', args: [arg, storageValue] },
                amount: '0',
                chain_id: chainId,
                balance: '0',
            };
            let result;
            try {
                result = yield this.rpc.runCode(viewScript);
            }
            catch (error) {
                const failWith = validateAndExtractFailwith(error);
                throw failWith
                    ? new ViewSimulationError(`The simulation of the Michelson view failed with: ${JSON.stringify(failWith)}`, this.viewName, failWith, error)
                    : error;
            }
            const viewResultSchema = new ParameterSchema(this.returnType);
            return viewResultSchema.Execute(result.storage.args[0]);
        });
    }
}

class ViewFactory {
    getView(viewName, rpc, contract, viewImplementation) {
        if (this.isMichelsonStorageView(viewImplementation)) {
            const viewValues = viewImplementation[ViewImplementationType.MICHELSON_STORAGE];
            if (!viewValues.returnType || !viewValues.code) {
                console.warn(`${viewName} is missing mandatory code or returnType property therefore it will be skipped.`);
                return;
            }
            return () => {
                const view = new MichelsonStorageView(viewName, contract, rpc, viewValues.returnType, viewValues.code, viewValues.parameter);
                return view;
            };
        }
    }
    getImplementationType(viewImplementation) {
        return Object.keys(viewImplementation)[0];
    }
    isMichelsonStorageView(viewImplementation) {
        return this.getImplementationType(viewImplementation) === ViewImplementationType.MICHELSON_STORAGE;
    }
}

const metadataBigMapType = {
    prim: 'big_map',
    args: [{ prim: 'string' }, { prim: 'bytes' }],
    annots: ['%metadata'],
};
class Tzip16ContractAbstraction {
    constructor(constractAbstraction, context) {
        this.constractAbstraction = constractAbstraction;
        this.context = context;
        this._viewFactory = new ViewFactory();
        this._metadataViewsObject = {};
        this._metadataProvider = context.metadataProvider;
    }
    findMetadataBigMap() {
        const metadataBigMapId = this.constractAbstraction.schema.FindFirstInTopLevelPair(this.constractAbstraction.script.storage, metadataBigMapType);
        if (!metadataBigMapId) {
            throw new BigMapMetadataNotFound();
        }
        return new BigMapAbstraction(new BigNumber(metadataBigMapId['int']), new Schema(metadataBigMapType), this.context.contract);
    }
    getUriOrFail() {
        return __awaiter(this, void 0, void 0, function* () {
            const metadataBigMap = this.findMetadataBigMap();
            const uri = yield metadataBigMap.get('');
            if (!uri) {
                throw new UriNotFound();
            }
            return uri;
        });
    }
    /**
     * @description Return an object containing the metadata, the uri, an optional integrity check result and an optional sha256 hash
     */
    getMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._metadataProvider) {
                throw new UnconfiguredMetadataProviderError();
            }
            if (!this._metadataEnvelope) {
                const uri = yield this.getUriOrFail();
                this._metadataEnvelope = yield this._metadataProvider.provideMetadata(this.constractAbstraction, bytes2Char(uri), this.context);
            }
            return this._metadataEnvelope;
        });
    }
    metadataViews() {
        return __awaiter(this, void 0, void 0, function* () {
            if (Object.keys(this._metadataViewsObject).length === 0) {
                yield this.initializeMetadataViewsList();
            }
            return this._metadataViewsObject;
        });
    }
    initializeMetadataViewsList() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { metadata } = yield this.getMetadata();
            const metadataViews = {};
            (_a = metadata.views) === null || _a === void 0 ? void 0 : _a.forEach((view) => this.createViewImplementations(view, metadataViews));
            this._metadataViewsObject = metadataViews;
        });
    }
    generateIndexedViewName(viewName, metadataViews) {
        let i = 1;
        if (viewName in metadataViews) {
            while (`${viewName}${i}` in metadataViews) {
                i++;
            }
            viewName = `${viewName}${i}`;
        }
        return viewName;
    }
    createViewImplementations(view, metadataViews) {
        var _a;
        for (const viewImplementation of (_a = view === null || view === void 0 ? void 0 : view.implementations) !== null && _a !== void 0 ? _a : []) {
            if (view.name) {
                // when views have the same name, add an index at the end of the name
                const viewName = this.generateIndexedViewName(view.name, metadataViews);
                const metadataView = this._viewFactory.getView(viewName, this.context.rpc, this.constractAbstraction, viewImplementation);
                if (metadataView) {
                    metadataViews[viewName] = metadataView;
                }
                else {
                    console.warn(`Skipped generating ${viewName} because the view has an unsupported type: ${this._viewFactory.getImplementationType(viewImplementation)}`);
                }
            }
        }
    }
}

const ABSTRACTION_KEY = Symbol('Tzip16ContractAbstractionObjectKey');
function tzip16(abs, context) {
    return Object.assign(abs, {
        // namespace tzip16
        tzip16() {
            if (!this[ABSTRACTION_KEY]) {
                this[ABSTRACTION_KEY] = new Tzip16ContractAbstraction(this, context);
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this[ABSTRACTION_KEY];
        },
    });
}

function calculateSHA256Hash(preimage) {
    return CryptoJS.SHA256(preimage).toString(CryptoJS.enc.Hex);
}

/**
 * @description: Metadata Provider
 */
class MetadataProvider {
    constructor(handlers) {
        this.handlers = handlers;
        this.PROTOCOL_REGEX = /(?:sha256:\/\/0x(.*)\/)?(https?|ipfs|tezos-storage):(.*)/;
    }
    /**
     * @description Fetch the metadata by using the appropriate handler based on the protcol found in the URI
     * @returns an object which contains the uri, the metadata, an optional integrity check result and an optional SHA256 hash
     * @param _contractAbstraction the contract abstraction which contains the URI in its storage
     * @param _uri the decoded uri found in the storage
     * @param context the TezosToolkit Context
     */
    provideMetadata(contractAbstraction, uri, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const uriInfo = this.extractProtocolInfo(uri);
            if (!uriInfo || !uriInfo.location) {
                throw new InvalidUri(uri);
            }
            const handler = this.handlers.get(uriInfo.protocol);
            if (!handler) {
                throw new ProtocolNotSupported(uriInfo.protocol);
            }
            const metadata = yield handler.getMetadata(contractAbstraction, uriInfo, context);
            const sha256Hash = calculateSHA256Hash(metadata);
            let metadataJSON;
            try {
                metadataJSON = JSON.parse(metadata);
            }
            catch (ex) {
                throw new InvalidMetadata(metadata);
            }
            return {
                uri,
                metadata: metadataJSON,
                integrityCheckResult: uriInfo.sha256hash ? uriInfo.sha256hash === sha256Hash : undefined,
                sha256Hash: uriInfo.sha256hash ? sha256Hash : undefined,
            };
        });
    }
    extractProtocolInfo(_uri) {
        const extractor = this.PROTOCOL_REGEX.exec(_uri);
        if (!extractor)
            return;
        return {
            sha256hash: extractor[1],
            protocol: extractor[2],
            location: extractor[3],
        };
    }
}

const DEFAULT_HANDLERS = new Map([
    ['http', new HttpHandler()],
    ['https', new HttpHandler()],
    ['tezos-storage', new TezosStorageHandler()],
    ['ipfs', new IpfsHttpHandler()]
]);
class Tzip16Module {
    constructor(metadataProvider) {
        this._metadataProvider = metadataProvider ? metadataProvider : new MetadataProvider(DEFAULT_HANDLERS);
    }
    configureContext(context) {
        Object.assign(context, { metadataProvider: this._metadataProvider });
    }
}

// IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!
const VERSION = {
    "commitHash": "81f0a5b103f867f57fbe5d526315c375a3788346",
    "version": "11.2.0"
};

export { BigMapMetadataNotFound, DEFAULT_HANDLERS, ForbiddenInstructionInViewCode, HttpHandler, InvalidMetadata, InvalidMetadataType, InvalidUri, InvalidViewParameterError, IpfsHttpHandler, MetadataNotFound, MetadataProvider, MichelsonStorageView, NoParameterExpectedError, ProtocolNotSupported, TezosStorageHandler, Tzip16ContractAbstraction, Tzip16Module, UnconfiguredMetadataProviderError, UriNotFound, VERSION, ViewFactory, ViewImplementationType, calculateSHA256Hash, tzip16 };
//# sourceMappingURL=taquito-tzip16.es6.js.map
