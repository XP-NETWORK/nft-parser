"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Operation = void 0;
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const types_1 = require("./types");
const utils_1 = require("@taquito/utils");
/**
 * @description Utility class to interact with Tezos operations
 */
class Operation {
    /**
     *
     * @param hash Operation hash
     * @param raw Raw operation that was injected
     * @param context Taquito context allowing access to rpc and signer
     */
    constructor(hash, raw, results, context) {
        this.hash = hash;
        this.raw = raw;
        this.results = results;
        this.context = context;
        this._pollingConfig$ = new rxjs_1.ReplaySubject(1);
        this._currentHeadPromise = undefined;
        // Caching the current head for one second
        this.currentHead$ = rxjs_1.defer(() => {
            if (!this._currentHeadPromise) {
                this._currentHeadPromise = this.context.rpc.getBlock();
                rxjs_1.timer(1000)
                    .pipe(operators_1.first())
                    .subscribe(() => {
                    this._currentHeadPromise = undefined;
                });
            }
            return rxjs_1.from(this._currentHeadPromise);
        });
        // Polling observable that emit until timeout is reached
        this.polling$ = rxjs_1.defer(() => this._pollingConfig$.pipe(operators_1.tap(({ timeout, interval }) => {
            if (timeout <= 0) {
                throw new Error('Timeout must be more than 0');
            }
            if (interval <= 0) {
                throw new Error('Interval must be more than 0');
            }
        }), operators_1.map((config) => (Object.assign(Object.assign({}, config), { timeoutAt: Math.ceil(config.timeout / config.interval) + 1, count: 0 }))), operators_1.switchMap((config) => rxjs_1.timer(0, config.interval * 1000).pipe(operators_1.mapTo(config))), operators_1.tap((config) => {
            config.count++;
            if (config.count > config.timeoutAt) {
                throw new Error(`Confirmation polling timed out`);
            }
        })));
        // Observable that emit once operation is seen in a block
        this.confirmed$ = this.polling$.pipe(operators_1.switchMapTo(this.currentHead$), operators_1.map((head) => {
            for (let i = 3; i >= 0; i--) {
                head.operations[i].forEach((op) => {
                    if (op.hash === this.hash) {
                        this._foundAt = head.header.level;
                    }
                });
            }
            if (head.header.level - this._foundAt >= 0) {
                return this._foundAt;
            }
        }), operators_1.filter((x) => x !== undefined), operators_1.first(), operators_1.shareReplay());
        this._foundAt = Number.POSITIVE_INFINITY;
        if (utils_1.validateOperation(this.hash) !== utils_1.ValidationResult.VALID) {
            throw new utils_1.InvalidOperationHashError(`Invalid Operation Hash: ${this.hash}`);
        }
        this.confirmed$.pipe(operators_1.first(), operators_1.catchError(() => {
            return rxjs_1.of(rxjs_1.EMPTY);
        })).subscribe();
    }
    get includedInBlock() {
        return this._foundAt;
    }
    get revealOperation() {
        return (Array.isArray(this.results) &&
            this.results.find((op) => op.kind === 'reveal'));
    }
    get revealStatus() {
        if (this.revealOperation) {
            return this.revealOperation.metadata.operation_result.status;
        }
        else {
            return 'unknown';
        }
    }
    get status() {
        return (this.results.map((result) => {
            if (types_1.hasMetadataWithResult(result)) {
                return result.metadata.operation_result.status;
            }
            else {
                return 'unknown';
            }
        })[0] || 'unknown');
    }
    /**
     *
     * @param confirmations [0] Number of confirmation to wait for
     * @param interval [10] Polling interval
     * @param timeout [180] Timeout
     */
    confirmation(confirmations, interval, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof confirmations !== 'undefined' && confirmations < 1) {
                throw new Error('Confirmation count must be at least 1');
            }
            const confirmationPollingIntervalSecond = this.context.config.confirmationPollingIntervalSecond !== undefined
                ? this.context.config.confirmationPollingIntervalSecond
                : yield this.context.getConfirmationPollingInterval();
            const { defaultConfirmationCount, confirmationPollingTimeoutSecond } = this.context.config;
            this._pollingConfig$.next({
                interval: interval || confirmationPollingIntervalSecond,
                timeout: timeout || confirmationPollingTimeoutSecond,
            });
            const conf = confirmations !== undefined ? confirmations : defaultConfirmationCount;
            return new Promise((resolve, reject) => {
                this.confirmed$
                    .pipe(operators_1.switchMap(() => this.polling$), operators_1.switchMap(() => this.currentHead$), operators_1.filter((head) => head.header.level - this._foundAt >= conf - 1), operators_1.first())
                    .subscribe((_) => {
                    resolve(this._foundAt + (conf - 1));
                }, reject);
            });
        });
    }
}
exports.Operation = Operation;
//# sourceMappingURL=operations.js.map